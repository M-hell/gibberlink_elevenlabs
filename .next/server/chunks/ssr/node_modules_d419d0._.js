module.exports = {

"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_require__("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "clsx": (()=>clsx),
    "default": (()=>__TURBOPACK__default__export__)
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}}),
"[project]/node_modules/class-variance-authority/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Copyright 2022 Joe Bell. All rights reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */ __turbopack_esm__({
    "cva": (()=>cva),
    "cx": (()=>cx)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)");
;
const falsyToString = (value)=>typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clsx"];
const cva = (base, config)=>(props)=>{
        var _config_compoundVariants;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
}}),
"[project]/node_modules/tailwind-merge/dist/bundle-mjs.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createTailwindMerge": (()=>createTailwindMerge),
    "extendTailwindMerge": (()=>extendTailwindMerge),
    "fromTheme": (()=>fromTheme),
    "getDefaultConfig": (()=>getDefaultConfig),
    "mergeConfigs": (()=>mergeConfigs),
    "twJoin": (()=>twJoin),
    "twMerge": (()=>twMerge),
    "validators": (()=>validators)
});
const CLASS_PART_SEPARATOR = '-';
const createClassGroupUtils = (config)=>{
    const classMap = createClassMap(config);
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
    const getClassGroupId = (className)=>{
        const classParts = className.split(CLASS_PART_SEPARATOR);
        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
        if (classParts[0] === '' && classParts.length !== 1) {
            classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier)=>{
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
            return [
                ...conflicts,
                ...conflictingClassGroupModifiers[classGroupId]
            ];
        }
        return conflicts;
    };
    return {
        getClassGroupId,
        getConflictingClassGroupIds
    };
};
const getGroupRecursive = (classParts, classPartObject)=>{
    if (classParts.length === 0) {
        return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
    if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
        return undefined;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({ validator })=>validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className)=>{
    if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
        if (property) {
            // I use two dots here because one dot is used as prefix for class groups in plugins
            return 'arbitrary..' + property;
        }
    }
};
/**
 * Exported for testing only
 */ const createClassMap = (config)=>{
    const { theme, classGroups } = config;
    const classMap = {
        nextPart: new Map(),
        validators: []
    };
    for(const classGroupId in classGroups){
        processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
    }
    return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme)=>{
    classGroup.forEach((classDefinition)=>{
        if (typeof classDefinition === 'string') {
            const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
            classPartObjectToEdit.classGroupId = classGroupId;
            return;
        }
        if (typeof classDefinition === 'function') {
            if (isThemeGetter(classDefinition)) {
                processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
                return;
            }
            classPartObject.validators.push({
                validator: classDefinition,
                classGroupId
            });
            return;
        }
        Object.entries(classDefinition).forEach(([key, classGroup])=>{
            processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
        });
    });
};
const getPart = (classPartObject, path)=>{
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart)=>{
        if (!currentClassPartObject.nextPart.has(pathPart)) {
            currentClassPartObject.nextPart.set(pathPart, {
                nextPart: new Map(),
                validators: []
            });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
};
const isThemeGetter = (func)=>func.isThemeGetter;
// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
const createLruCache = (maxCacheSize)=>{
    if (maxCacheSize < 1) {
        return {
            get: ()=>undefined,
            set: ()=>{}
        };
    }
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    const update = (key, value)=>{
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
            cacheSize = 0;
            previousCache = cache;
            cache = new Map();
        }
    };
    return {
        get (key) {
            let value = cache.get(key);
            if (value !== undefined) {
                return value;
            }
            if ((value = previousCache.get(key)) !== undefined) {
                update(key, value);
                return value;
            }
        },
        set (key, value) {
            if (cache.has(key)) {
                cache.set(key, value);
            } else {
                update(key, value);
            }
        }
    };
};
const IMPORTANT_MODIFIER = '!';
const MODIFIER_SEPARATOR = ':';
const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
const createParseClassName = (config)=>{
    const { prefix, experimentalParseClassName } = config;
    /**
   * Parse class name into parts.
   *
   * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
   * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
   */ let parseClassName = (className)=>{
        const modifiers = [];
        let bracketDepth = 0;
        let parenDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for(let index = 0; index < className.length; index++){
            let currentCharacter = className[index];
            if (bracketDepth === 0 && parenDepth === 0) {
                if (currentCharacter === MODIFIER_SEPARATOR) {
                    modifiers.push(className.slice(modifierStart, index));
                    modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
                    continue;
                }
                if (currentCharacter === '/') {
                    postfixModifierPosition = index;
                    continue;
                }
            }
            if (currentCharacter === '[') {
                bracketDepth++;
            } else if (currentCharacter === ']') {
                bracketDepth--;
            } else if (currentCharacter === '(') {
                parenDepth++;
            } else if (currentCharacter === ')') {
                parenDepth--;
            }
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
        const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
        return {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition
        };
    };
    if (prefix) {
        const fullPrefix = prefix + MODIFIER_SEPARATOR;
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
                isExternal: true,
                modifiers: [],
                hasImportantModifier: false,
                baseClassName: className,
                maybePostfixModifierPosition: undefined
            };
    }
    if (experimentalParseClassName) {
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>experimentalParseClassName({
                className,
                parseClassName: parseClassNameOriginal
            });
    }
    return parseClassName;
};
const stripImportantModifier = (baseClassName)=>{
    if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(0, baseClassName.length - 1);
    }
    /**
   * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
   * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
   */ if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(1);
    }
    return baseClassName;
};
/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */ const createSortModifiers = (config)=>{
    const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier)=>[
            modifier,
            true
        ]));
    const sortModifiers = (modifiers)=>{
        if (modifiers.length <= 1) {
            return modifiers;
        }
        const sortedModifiers = [];
        let unsortedModifiers = [];
        modifiers.forEach((modifier)=>{
            const isPositionSensitive = modifier[0] === '[' || orderSensitiveModifiers[modifier];
            if (isPositionSensitive) {
                sortedModifiers.push(...unsortedModifiers.sort(), modifier);
                unsortedModifiers = [];
            } else {
                unsortedModifiers.push(modifier);
            }
        });
        sortedModifiers.push(...unsortedModifiers.sort());
        return sortedModifiers;
    };
    return sortModifiers;
};
const createConfigUtils = (config)=>({
        cache: createLruCache(config.cacheSize),
        parseClassName: createParseClassName(config),
        sortModifiers: createSortModifiers(config),
        ...createClassGroupUtils(config)
    });
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils)=>{
    const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } = configUtils;
    /**
   * Set of classGroupIds in following format:
   * `{importantModifier}{variantModifiers}{classGroupId}`
   * @example 'float'
   * @example 'hover:focus:bg-color'
   * @example 'md:!pr'
   */ const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = '';
    for(let index = classNames.length - 1; index >= 0; index -= 1){
        const originalClassName = classNames[index];
        const { isExternal, modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition } = parseClassName(originalClassName);
        if (isExternal) {
            result = originalClassName + (result.length > 0 ? ' ' + result : result);
            continue;
        }
        let hasPostfixModifier = !!maybePostfixModifierPosition;
        let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        if (!classGroupId) {
            if (!hasPostfixModifier) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            classGroupId = getClassGroupId(baseClassName);
            if (!classGroupId) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(':');
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.includes(classId)) {
            continue;
        }
        classGroupsInConflict.push(classId);
        const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
        for(let i = 0; i < conflictGroups.length; ++i){
            const group = conflictGroups[i];
            classGroupsInConflict.push(modifierId + group);
        }
        // Tailwind class not in conflict
        result = originalClassName + (result.length > 0 ? ' ' + result : result);
    }
    return result;
};
/**
 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
 *
 * Specifically:
 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
 *
 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
 */ function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = '';
    while(index < arguments.length){
        if (argument = arguments[index++]) {
            if (resolvedValue = toValue(argument)) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
}
const toValue = (mix)=>{
    if (typeof mix === 'string') {
        return mix;
    }
    let resolvedValue;
    let string = '';
    for(let k = 0; k < mix.length; k++){
        if (mix[k]) {
            if (resolvedValue = toValue(mix[k])) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
        const config = createConfigRest.reduce((previousConfig, createConfigCurrent)=>createConfigCurrent(previousConfig), createConfigFirst());
        configUtils = createConfigUtils(config);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
        const cachedResult = cacheGet(classList);
        if (cachedResult) {
            return cachedResult;
        }
        const result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
    }
    return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
    };
}
const fromTheme = (key)=>{
    const themeGetter = (theme)=>theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
// Shadow always begins with x and y offset separated by underscore optionally prepended by inset
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value)=>fractionRegex.test(value);
const isNumber = (value)=>Boolean(value) && !Number.isNaN(Number(value));
const isInteger = (value)=>Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value)=>value.endsWith('%') && isNumber(value.slice(0, -1));
const isTshirtSize = (value)=>tshirtUnitRegex.test(value);
const isAny = ()=>true;
const isLengthOnly = (value)=>// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
const isNever = ()=>false;
const isShadow = (value)=>shadowRegex.test(value);
const isImage = (value)=>imageRegex.test(value);
const isAnyNonArbitrary = (value)=>!isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value)=>getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value)=>arbitraryValueRegex.test(value);
const isArbitraryLength = (value)=>getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value)=>getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value)=>getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value)=>getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value)=>getIsArbitraryValue(value, isNever, isShadow);
const isArbitraryVariable = (value)=>arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value)=>getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value)=>getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value)=>getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value)=>getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value)=>getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value)=>getIsArbitraryVariable(value, isLabelShadow, true);
// Helpers
const getIsArbitraryValue = (value, testLabel, testValue)=>{
    const result = arbitraryValueRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return testValue(result[2]);
    }
    return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false)=>{
    const result = arbitraryVariableRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return shouldMatchNoLabel;
    }
    return false;
};
// Labels
const isLabelPosition = (label)=>label === 'position';
const imageLabels = /*#__PURE__*/ new Set([
    'image',
    'url'
]);
const isLabelImage = (label)=>imageLabels.has(label);
const sizeLabels = /*#__PURE__*/ new Set([
    'length',
    'size',
    'percentage'
]);
const isLabelSize = (label)=>sizeLabels.has(label);
const isLabelLength = (label)=>label === 'length';
const isLabelNumber = (label)=>label === 'number';
const isLabelFamilyName = (label)=>label === 'family-name';
const isLabelShadow = (label)=>label === 'shadow';
const validators = /*#__PURE__*/ Object.defineProperty({
    __proto__: null,
    isAny,
    isAnyNonArbitrary,
    isArbitraryImage,
    isArbitraryLength,
    isArbitraryNumber,
    isArbitraryPosition,
    isArbitraryShadow,
    isArbitrarySize,
    isArbitraryValue,
    isArbitraryVariable,
    isArbitraryVariableFamilyName,
    isArbitraryVariableImage,
    isArbitraryVariableLength,
    isArbitraryVariablePosition,
    isArbitraryVariableShadow,
    isArbitraryVariableSize,
    isFraction,
    isInteger,
    isNumber,
    isPercent,
    isTshirtSize
}, Symbol.toStringTag, {
    value: 'Module'
});
const getDefaultConfig = ()=>{
    /**
   * Theme getters for theme variable namespaces
   * @see https://tailwindcss.com/docs/theme#theme-variable-namespaces
   */ /***/ const themeColor = fromTheme('color');
    const themeFont = fromTheme('font');
    const themeText = fromTheme('text');
    const themeFontWeight = fromTheme('font-weight');
    const themeTracking = fromTheme('tracking');
    const themeLeading = fromTheme('leading');
    const themeBreakpoint = fromTheme('breakpoint');
    const themeContainer = fromTheme('container');
    const themeSpacing = fromTheme('spacing');
    const themeRadius = fromTheme('radius');
    const themeShadow = fromTheme('shadow');
    const themeInsetShadow = fromTheme('inset-shadow');
    const themeDropShadow = fromTheme('drop-shadow');
    const themeBlur = fromTheme('blur');
    const themePerspective = fromTheme('perspective');
    const themeAspect = fromTheme('aspect');
    const themeEase = fromTheme('ease');
    const themeAnimate = fromTheme('animate');
    /**
   * Helpers to avoid repeating the same scales
   *
   * We use functions that create a new array every time they're called instead of static arrays.
   * This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.
   */ /***/ const scaleBreak = ()=>[
            'auto',
            'avoid',
            'all',
            'avoid-page',
            'page',
            'left',
            'right',
            'column'
        ];
    const scalePosition = ()=>[
            'bottom',
            'center',
            'left',
            'left-bottom',
            'left-top',
            'right',
            'right-bottom',
            'right-top',
            'top'
        ];
    const scaleOverflow = ()=>[
            'auto',
            'hidden',
            'clip',
            'visible',
            'scroll'
        ];
    const scaleOverscroll = ()=>[
            'auto',
            'contain',
            'none'
        ];
    const scaleInset = ()=>[
            isFraction,
            'px',
            'full',
            'auto',
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scaleGridTemplateColsRows = ()=>[
            isInteger,
            'none',
            'subgrid',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartAndEnd = ()=>[
            'auto',
            {
                span: [
                    'full',
                    isInteger,
                    isArbitraryVariable,
                    isArbitraryValue
                ]
            },
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartOrEnd = ()=>[
            isInteger,
            'auto',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridAutoColsRows = ()=>[
            'auto',
            'min',
            'max',
            'fr',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGap = ()=>[
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scaleAlignPrimaryAxis = ()=>[
            'start',
            'end',
            'center',
            'between',
            'around',
            'evenly',
            'stretch',
            'baseline'
        ];
    const scaleAlignSecondaryAxis = ()=>[
            'start',
            'end',
            'center',
            'stretch'
        ];
    const scaleUnambiguousSpacing = ()=>[
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scalePadding = ()=>[
            'px',
            ...scaleUnambiguousSpacing()
        ];
    const scaleMargin = ()=>[
            'px',
            'auto',
            ...scaleUnambiguousSpacing()
        ];
    const scaleSizing = ()=>[
            isFraction,
            'auto',
            'px',
            'full',
            'dvw',
            'dvh',
            'lvw',
            'lvh',
            'svw',
            'svh',
            'min',
            'max',
            'fit',
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scaleColor = ()=>[
            themeColor,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGradientStopPosition = ()=>[
            isPercent,
            isArbitraryLength
        ];
    const scaleRadius = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            'full',
            themeRadius,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleBorderWidth = ()=>[
            '',
            isNumber,
            isArbitraryVariableLength,
            isArbitraryLength
        ];
    const scaleLineStyle = ()=>[
            'solid',
            'dashed',
            'dotted',
            'double'
        ];
    const scaleBlendMode = ()=>[
            'normal',
            'multiply',
            'screen',
            'overlay',
            'darken',
            'lighten',
            'color-dodge',
            'color-burn',
            'hard-light',
            'soft-light',
            'difference',
            'exclusion',
            'hue',
            'saturation',
            'color',
            'luminosity'
        ];
    const scaleBlur = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            themeBlur,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleOrigin = ()=>[
            'center',
            'top',
            'top-right',
            'right',
            'bottom-right',
            'bottom',
            'bottom-left',
            'left',
            'top-left',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleRotate = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleScale = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleSkew = ()=>[
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleTranslate = ()=>[
            isFraction,
            'full',
            'px',
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    return {
        cacheSize: 500,
        theme: {
            animate: [
                'spin',
                'ping',
                'pulse',
                'bounce'
            ],
            aspect: [
                'video'
            ],
            blur: [
                isTshirtSize
            ],
            breakpoint: [
                isTshirtSize
            ],
            color: [
                isAny
            ],
            container: [
                isTshirtSize
            ],
            'drop-shadow': [
                isTshirtSize
            ],
            ease: [
                'in',
                'out',
                'in-out'
            ],
            font: [
                isAnyNonArbitrary
            ],
            'font-weight': [
                'thin',
                'extralight',
                'light',
                'normal',
                'medium',
                'semibold',
                'bold',
                'extrabold',
                'black'
            ],
            'inset-shadow': [
                isTshirtSize
            ],
            leading: [
                'none',
                'tight',
                'snug',
                'normal',
                'relaxed',
                'loose'
            ],
            perspective: [
                'dramatic',
                'near',
                'normal',
                'midrange',
                'distant',
                'none'
            ],
            radius: [
                isTshirtSize
            ],
            shadow: [
                isTshirtSize
            ],
            spacing: [
                isNumber
            ],
            text: [
                isTshirtSize
            ],
            tracking: [
                'tighter',
                'tight',
                'normal',
                'wide',
                'wider',
                'widest'
            ]
        },
        classGroups: {
            // --------------
            // --- Layout ---
            // --------------
            /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */ aspect: [
                {
                    aspect: [
                        'auto',
                        'square',
                        isFraction,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeAspect
                    ]
                }
            ],
            /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */ container: [
                'container'
            ],
            /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */ columns: [
                {
                    columns: [
                        isNumber,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeContainer
                    ]
                }
            ],
            /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */ 'break-after': [
                {
                    'break-after': scaleBreak()
                }
            ],
            /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */ 'break-before': [
                {
                    'break-before': scaleBreak()
                }
            ],
            /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */ 'break-inside': [
                {
                    'break-inside': [
                        'auto',
                        'avoid',
                        'avoid-page',
                        'avoid-column'
                    ]
                }
            ],
            /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */ 'box-decoration': [
                {
                    'box-decoration': [
                        'slice',
                        'clone'
                    ]
                }
            ],
            /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */ box: [
                {
                    box: [
                        'border',
                        'content'
                    ]
                }
            ],
            /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */ display: [
                'block',
                'inline-block',
                'inline',
                'flex',
                'inline-flex',
                'table',
                'inline-table',
                'table-caption',
                'table-cell',
                'table-column',
                'table-column-group',
                'table-footer-group',
                'table-header-group',
                'table-row-group',
                'table-row',
                'flow-root',
                'grid',
                'inline-grid',
                'contents',
                'list-item',
                'hidden'
            ],
            /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */ sr: [
                'sr-only',
                'not-sr-only'
            ],
            /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */ float: [
                {
                    float: [
                        'right',
                        'left',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */ clear: [
                {
                    clear: [
                        'left',
                        'right',
                        'both',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */ isolation: [
                'isolate',
                'isolation-auto'
            ],
            /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */ 'object-fit': [
                {
                    object: [
                        'contain',
                        'cover',
                        'fill',
                        'none',
                        'scale-down'
                    ]
                }
            ],
            /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */ 'object-position': [
                {
                    object: [
                        ...scalePosition(),
                        isArbitraryValue,
                        isArbitraryVariable
                    ]
                }
            ],
            /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */ overflow: [
                {
                    overflow: scaleOverflow()
                }
            ],
            /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-x': [
                {
                    'overflow-x': scaleOverflow()
                }
            ],
            /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-y': [
                {
                    'overflow-y': scaleOverflow()
                }
            ],
            /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ overscroll: [
                {
                    overscroll: scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-x': [
                {
                    'overscroll-x': scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-y': [
                {
                    'overscroll-y': scaleOverscroll()
                }
            ],
            /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */ position: [
                'static',
                'fixed',
                'absolute',
                'relative',
                'sticky'
            ],
            /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ inset: [
                {
                    inset: scaleInset()
                }
            ],
            /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-x': [
                {
                    'inset-x': scaleInset()
                }
            ],
            /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-y': [
                {
                    'inset-y': scaleInset()
                }
            ],
            /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ start: [
                {
                    start: scaleInset()
                }
            ],
            /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ end: [
                {
                    end: scaleInset()
                }
            ],
            /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ top: [
                {
                    top: scaleInset()
                }
            ],
            /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ right: [
                {
                    right: scaleInset()
                }
            ],
            /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ bottom: [
                {
                    bottom: scaleInset()
                }
            ],
            /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ left: [
                {
                    left: scaleInset()
                }
            ],
            /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */ visibility: [
                'visible',
                'invisible',
                'collapse'
            ],
            /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */ z: [
                {
                    z: [
                        isInteger,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------------
            // --- Flexbox and Grid ---
            // ------------------------
            /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */ basis: [
                {
                    basis: [
                        isFraction,
                        'full',
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue,
                        themeContainer,
                        themeSpacing
                    ]
                }
            ],
            /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */ 'flex-direction': [
                {
                    flex: [
                        'row',
                        'row-reverse',
                        'col',
                        'col-reverse'
                    ]
                }
            ],
            /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */ 'flex-wrap': [
                {
                    flex: [
                        'nowrap',
                        'wrap',
                        'wrap-reverse'
                    ]
                }
            ],
            /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */ flex: [
                {
                    flex: [
                        isNumber,
                        isFraction,
                        'auto',
                        'initial',
                        'none',
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */ grow: [
                {
                    grow: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */ shrink: [
                {
                    shrink: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */ order: [
                {
                    order: [
                        isInteger,
                        'first',
                        'last',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */ 'grid-cols': [
                {
                    'grid-cols': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start-end': [
                {
                    col: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start': [
                {
                    'col-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-end': [
                {
                    'col-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */ 'grid-rows': [
                {
                    'grid-rows': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start-end': [
                {
                    row: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start': [
                {
                    'row-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-end': [
                {
                    'row-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */ 'grid-flow': [
                {
                    'grid-flow': [
                        'row',
                        'col',
                        'dense',
                        'row-dense',
                        'col-dense'
                    ]
                }
            ],
            /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */ 'auto-cols': [
                {
                    'auto-cols': scaleGridAutoColsRows()
                }
            ],
            /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */ 'auto-rows': [
                {
                    'auto-rows': scaleGridAutoColsRows()
                }
            ],
            /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */ gap: [
                {
                    gap: scaleGap()
                }
            ],
            /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-x': [
                {
                    'gap-x': scaleGap()
                }
            ],
            /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-y': [
                {
                    'gap-y': scaleGap()
                }
            ],
            /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */ 'justify-content': [
                {
                    justify: [
                        ...scaleAlignPrimaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */ 'justify-items': [
                {
                    'justify-items': [
                        ...scaleAlignSecondaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */ 'justify-self': [
                {
                    'justify-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */ 'align-content': [
                {
                    content: [
                        'normal',
                        ...scaleAlignPrimaryAxis()
                    ]
                }
            ],
            /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */ 'align-items': [
                {
                    items: [
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */ 'align-self': [
                {
                    self: [
                        'auto',
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */ 'place-content': [
                {
                    'place-content': scaleAlignPrimaryAxis()
                }
            ],
            /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */ 'place-items': [
                {
                    'place-items': [
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */ 'place-self': [
                {
                    'place-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            // Spacing
            /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */ p: [
                {
                    p: scalePadding()
                }
            ],
            /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */ px: [
                {
                    px: scalePadding()
                }
            ],
            /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */ py: [
                {
                    py: scalePadding()
                }
            ],
            /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */ ps: [
                {
                    ps: scalePadding()
                }
            ],
            /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */ pe: [
                {
                    pe: scalePadding()
                }
            ],
            /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */ pt: [
                {
                    pt: scalePadding()
                }
            ],
            /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */ pr: [
                {
                    pr: scalePadding()
                }
            ],
            /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */ pb: [
                {
                    pb: scalePadding()
                }
            ],
            /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */ pl: [
                {
                    pl: scalePadding()
                }
            ],
            /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */ m: [
                {
                    m: scaleMargin()
                }
            ],
            /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */ mx: [
                {
                    mx: scaleMargin()
                }
            ],
            /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */ my: [
                {
                    my: scaleMargin()
                }
            ],
            /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */ ms: [
                {
                    ms: scaleMargin()
                }
            ],
            /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */ me: [
                {
                    me: scaleMargin()
                }
            ],
            /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */ mt: [
                {
                    mt: scaleMargin()
                }
            ],
            /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */ mr: [
                {
                    mr: scaleMargin()
                }
            ],
            /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */ mb: [
                {
                    mb: scaleMargin()
                }
            ],
            /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */ ml: [
                {
                    ml: scaleMargin()
                }
            ],
            /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x': [
                {
                    'space-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x-reverse': [
                'space-x-reverse'
            ],
            /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y': [
                {
                    'space-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y-reverse': [
                'space-y-reverse'
            ],
            // --------------
            // --- Sizing ---
            // --------------
            /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */ /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */ size: [
                {
                    size: scaleSizing()
                }
            ],
            w: [
                {
                    w: [
                        themeContainer,
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */ 'min-w': [
                {
                    'min-w': [
                        themeContainer,
                        'screen',
                        /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */ 'max-w': [
                {
                    'max-w': [
                        themeContainer,
                        'screen',
                        'none',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'prose',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ {
                            screen: [
                                themeBreakpoint
                            ]
                        },
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */ h: [
                {
                    h: [
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */ 'min-h': [
                {
                    'min-h': [
                        'screen',
                        'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */ 'max-h': [
                {
                    'max-h': [
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            // ------------------
            // --- Typography ---
            // ------------------
            /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */ 'font-size': [
                {
                    text: [
                        'base',
                        themeText,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */ 'font-smoothing': [
                'antialiased',
                'subpixel-antialiased'
            ],
            /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */ 'font-style': [
                'italic',
                'not-italic'
            ],
            /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */ 'font-weight': [
                {
                    font: [
                        themeFontWeight,
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */ 'font-stretch': [
                {
                    'font-stretch': [
                        'ultra-condensed',
                        'extra-condensed',
                        'condensed',
                        'semi-condensed',
                        'normal',
                        'semi-expanded',
                        'expanded',
                        'extra-expanded',
                        'ultra-expanded',
                        isPercent,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */ 'font-family': [
                {
                    font: [
                        isArbitraryVariableFamilyName,
                        isArbitraryValue,
                        themeFont
                    ]
                }
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-normal': [
                'normal-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-ordinal': [
                'ordinal'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-slashed-zero': [
                'slashed-zero'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-figure': [
                'lining-nums',
                'oldstyle-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-spacing': [
                'proportional-nums',
                'tabular-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-fraction': [
                'diagonal-fractions',
                'stacked-fractions'
            ],
            /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */ tracking: [
                {
                    tracking: [
                        themeTracking,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */ 'line-clamp': [
                {
                    'line-clamp': [
                        isNumber,
                        'none',
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */ leading: [
                {
                    leading: [
                        isArbitraryVariable,
                        isArbitraryValue,
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ themeLeading,
                        themeSpacing
                    ]
                }
            ],
            /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */ 'list-image': [
                {
                    'list-image': [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */ 'list-style-position': [
                {
                    list: [
                        'inside',
                        'outside'
                    ]
                }
            ],
            /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */ 'list-style-type': [
                {
                    list: [
                        'disc',
                        'decimal',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */ 'text-alignment': [
                {
                    text: [
                        'left',
                        'center',
                        'right',
                        'justify',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */ 'placeholder-color': [
                {
                    placeholder: scaleColor()
                }
            ],
            /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */ 'text-color': [
                {
                    text: scaleColor()
                }
            ],
            /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */ 'text-decoration': [
                'underline',
                'overline',
                'line-through',
                'no-underline'
            ],
            /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */ 'text-decoration-style': [
                {
                    decoration: [
                        ...scaleLineStyle(),
                        'wavy'
                    ]
                }
            ],
            /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */ 'text-decoration-thickness': [
                {
                    decoration: [
                        isNumber,
                        'from-font',
                        'auto',
                        isArbitraryVariable,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */ 'text-decoration-color': [
                {
                    decoration: scaleColor()
                }
            ],
            /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */ 'underline-offset': [
                {
                    'underline-offset': [
                        isNumber,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */ 'text-transform': [
                'uppercase',
                'lowercase',
                'capitalize',
                'normal-case'
            ],
            /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */ 'text-overflow': [
                'truncate',
                'text-ellipsis',
                'text-clip'
            ],
            /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */ 'text-wrap': [
                {
                    text: [
                        'wrap',
                        'nowrap',
                        'balance',
                        'pretty'
                    ]
                }
            ],
            /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */ indent: [
                {
                    indent: [
                        'px',
                        ...scaleUnambiguousSpacing()
                    ]
                }
            ],
            /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */ 'vertical-align': [
                {
                    align: [
                        'baseline',
                        'top',
                        'middle',
                        'bottom',
                        'text-top',
                        'text-bottom',
                        'sub',
                        'super',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */ whitespace: [
                {
                    whitespace: [
                        'normal',
                        'nowrap',
                        'pre',
                        'pre-line',
                        'pre-wrap',
                        'break-spaces'
                    ]
                }
            ],
            /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */ break: [
                {
                    break: [
                        'normal',
                        'words',
                        'all',
                        'keep'
                    ]
                }
            ],
            /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */ hyphens: [
                {
                    hyphens: [
                        'none',
                        'manual',
                        'auto'
                    ]
                }
            ],
            /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */ content: [
                {
                    content: [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -------------------
            // --- Backgrounds ---
            // -------------------
            /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */ 'bg-attachment': [
                {
                    bg: [
                        'fixed',
                        'local',
                        'scroll'
                    ]
                }
            ],
            /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */ 'bg-clip': [
                {
                    'bg-clip': [
                        'border',
                        'padding',
                        'content',
                        'text'
                    ]
                }
            ],
            /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */ 'bg-origin': [
                {
                    'bg-origin': [
                        'border',
                        'padding',
                        'content'
                    ]
                }
            ],
            /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */ 'bg-position': [
                {
                    bg: [
                        ...scalePosition(),
                        isArbitraryVariablePosition,
                        isArbitraryPosition
                    ]
                }
            ],
            /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */ 'bg-repeat': [
                {
                    bg: [
                        'no-repeat',
                        {
                            repeat: [
                                '',
                                'x',
                                'y',
                                'space',
                                'round'
                            ]
                        }
                    ]
                }
            ],
            /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */ 'bg-size': [
                {
                    bg: [
                        'auto',
                        'cover',
                        'contain',
                        isArbitraryVariableSize,
                        isArbitrarySize
                    ]
                }
            ],
            /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */ 'bg-image': [
                {
                    bg: [
                        'none',
                        {
                            linear: [
                                {
                                    to: [
                                        't',
                                        'tr',
                                        'r',
                                        'br',
                                        'b',
                                        'bl',
                                        'l',
                                        'tl'
                                    ]
                                },
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            radial: [
                                '',
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            conic: [
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ]
                        },
                        isArbitraryVariableImage,
                        isArbitraryImage
                    ]
                }
            ],
            /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */ 'bg-color': [
                {
                    bg: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from-pos': [
                {
                    from: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via-pos': [
                {
                    via: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to-pos': [
                {
                    to: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from': [
                {
                    from: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via': [
                {
                    via: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to': [
                {
                    to: scaleColor()
                }
            ],
            // ---------------
            // --- Borders ---
            // ---------------
            /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */ rounded: [
                {
                    rounded: scaleRadius()
                }
            ],
            /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-s': [
                {
                    'rounded-s': scaleRadius()
                }
            ],
            /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-e': [
                {
                    'rounded-e': scaleRadius()
                }
            ],
            /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-t': [
                {
                    'rounded-t': scaleRadius()
                }
            ],
            /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-r': [
                {
                    'rounded-r': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-b': [
                {
                    'rounded-b': scaleRadius()
                }
            ],
            /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-l': [
                {
                    'rounded-l': scaleRadius()
                }
            ],
            /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ss': [
                {
                    'rounded-ss': scaleRadius()
                }
            ],
            /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-se': [
                {
                    'rounded-se': scaleRadius()
                }
            ],
            /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ee': [
                {
                    'rounded-ee': scaleRadius()
                }
            ],
            /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-es': [
                {
                    'rounded-es': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tl': [
                {
                    'rounded-tl': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tr': [
                {
                    'rounded-tr': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-br': [
                {
                    'rounded-br': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-bl': [
                {
                    'rounded-bl': scaleRadius()
                }
            ],
            /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w': [
                {
                    border: scaleBorderWidth()
                }
            ],
            /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-x': [
                {
                    'border-x': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-y': [
                {
                    'border-y': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-s': [
                {
                    'border-s': scaleBorderWidth()
                }
            ],
            /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-e': [
                {
                    'border-e': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-t': [
                {
                    'border-t': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-r': [
                {
                    'border-r': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-b': [
                {
                    'border-b': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-l': [
                {
                    'border-l': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x': [
                {
                    'divide-x': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x-reverse': [
                'divide-x-reverse'
            ],
            /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y': [
                {
                    'divide-y': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y-reverse': [
                'divide-y-reverse'
            ],
            /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */ 'border-style': [
                {
                    border: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */ 'divide-style': [
                {
                    divide: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color': [
                {
                    border: scaleColor()
                }
            ],
            /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-x': [
                {
                    'border-x': scaleColor()
                }
            ],
            /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-y': [
                {
                    'border-y': scaleColor()
                }
            ],
            /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-s': [
                {
                    'border-s': scaleColor()
                }
            ],
            /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-e': [
                {
                    'border-e': scaleColor()
                }
            ],
            /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-t': [
                {
                    'border-t': scaleColor()
                }
            ],
            /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-r': [
                {
                    'border-r': scaleColor()
                }
            ],
            /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-b': [
                {
                    'border-b': scaleColor()
                }
            ],
            /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-l': [
                {
                    'border-l': scaleColor()
                }
            ],
            /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */ 'divide-color': [
                {
                    divide: scaleColor()
                }
            ],
            /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */ 'outline-style': [
                {
                    outline: [
                        ...scaleLineStyle(),
                        'none',
                        'hidden'
                    ]
                }
            ],
            /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */ 'outline-offset': [
                {
                    'outline-offset': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */ 'outline-w': [
                {
                    outline: [
                        '',
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */ 'outline-color': [
                {
                    outline: [
                        themeColor
                    ]
                }
            ],
            // ---------------
            // --- Effects ---
            // ---------------
            /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */ shadow: [
                {
                    shadow: [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */ 'shadow-color': [
                {
                    shadow: scaleColor()
                }
            ],
            /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */ 'inset-shadow': [
                {
                    'inset-shadow': [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue,
                        themeInsetShadow
                    ]
                }
            ],
            /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */ 'inset-shadow-color': [
                {
                    'inset-shadow': scaleColor()
                }
            ],
            /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */ 'ring-w': [
                {
                    ring: scaleBorderWidth()
                }
            ],
            /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-w-inset': [
                'ring-inset'
            ],
            /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */ 'ring-color': [
                {
                    ring: scaleColor()
                }
            ],
            /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-w': [
                {
                    'ring-offset': [
                        isNumber,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-color': [
                {
                    'ring-offset': scaleColor()
                }
            ],
            /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */ 'inset-ring-w': [
                {
                    'inset-ring': scaleBorderWidth()
                }
            ],
            /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */ 'inset-ring-color': [
                {
                    'inset-ring': scaleColor()
                }
            ],
            /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */ opacity: [
                {
                    opacity: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */ 'mix-blend': [
                {
                    'mix-blend': [
                        ...scaleBlendMode(),
                        'plus-darker',
                        'plus-lighter'
                    ]
                }
            ],
            /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */ 'bg-blend': [
                {
                    'bg-blend': scaleBlendMode()
                }
            ],
            // ---------------
            // --- Filters ---
            // ---------------
            /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */ filter: [
                {
                    filter: [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */ blur: [
                {
                    blur: scaleBlur()
                }
            ],
            /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */ brightness: [
                {
                    brightness: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */ contrast: [
                {
                    contrast: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */ 'drop-shadow': [
                {
                    'drop-shadow': [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeDropShadow,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */ grayscale: [
                {
                    grayscale: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */ 'hue-rotate': [
                {
                    'hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */ invert: [
                {
                    invert: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */ saturate: [
                {
                    saturate: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */ sepia: [
                {
                    sepia: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */ 'backdrop-filter': [
                {
                    'backdrop-filter': [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */ 'backdrop-blur': [
                {
                    'backdrop-blur': scaleBlur()
                }
            ],
            /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */ 'backdrop-brightness': [
                {
                    'backdrop-brightness': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */ 'backdrop-contrast': [
                {
                    'backdrop-contrast': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */ 'backdrop-grayscale': [
                {
                    'backdrop-grayscale': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */ 'backdrop-hue-rotate': [
                {
                    'backdrop-hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */ 'backdrop-invert': [
                {
                    'backdrop-invert': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */ 'backdrop-opacity': [
                {
                    'backdrop-opacity': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */ 'backdrop-saturate': [
                {
                    'backdrop-saturate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */ 'backdrop-sepia': [
                {
                    'backdrop-sepia': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // --------------
            // --- Tables ---
            // --------------
            /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */ 'border-collapse': [
                {
                    border: [
                        'collapse',
                        'separate'
                    ]
                }
            ],
            /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing': [
                {
                    'border-spacing': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-x': [
                {
                    'border-spacing-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-y': [
                {
                    'border-spacing-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */ 'table-layout': [
                {
                    table: [
                        'auto',
                        'fixed'
                    ]
                }
            ],
            /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */ caption: [
                {
                    caption: [
                        'top',
                        'bottom'
                    ]
                }
            ],
            // ---------------------------------
            // --- Transitions and Animation ---
            // ---------------------------------
            /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */ transition: [
                {
                    transition: [
                        '',
                        'all',
                        'colors',
                        'opacity',
                        'shadow',
                        'transform',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */ 'transition-behavior': [
                {
                    transition: [
                        'normal',
                        'discrete'
                    ]
                }
            ],
            /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */ duration: [
                {
                    duration: [
                        isNumber,
                        'initial',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */ ease: [
                {
                    ease: [
                        'linear',
                        'initial',
                        themeEase,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */ delay: [
                {
                    delay: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */ animate: [
                {
                    animate: [
                        'none',
                        themeAnimate,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------
            // --- Transforms ---
            // ------------------
            /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */ backface: [
                {
                    backface: [
                        'hidden',
                        'visible'
                    ]
                }
            ],
            /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */ perspective: [
                {
                    perspective: [
                        themePerspective,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */ 'perspective-origin': [
                {
                    'perspective-origin': scaleOrigin()
                }
            ],
            /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */ rotate: [
                {
                    rotate: scaleRotate()
                }
            ],
            /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-x': [
                {
                    'rotate-x': scaleRotate()
                }
            ],
            /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-y': [
                {
                    'rotate-y': scaleRotate()
                }
            ],
            /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-z': [
                {
                    'rotate-z': scaleRotate()
                }
            ],
            /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */ scale: [
                {
                    scale: scaleScale()
                }
            ],
            /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-x': [
                {
                    'scale-x': scaleScale()
                }
            ],
            /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-y': [
                {
                    'scale-y': scaleScale()
                }
            ],
            /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-z': [
                {
                    'scale-z': scaleScale()
                }
            ],
            /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-3d': [
                'scale-3d'
            ],
            /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */ skew: [
                {
                    skew: scaleSkew()
                }
            ],
            /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-x': [
                {
                    'skew-x': scaleSkew()
                }
            ],
            /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-y': [
                {
                    'skew-y': scaleSkew()
                }
            ],
            /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */ transform: [
                {
                    transform: [
                        isArbitraryVariable,
                        isArbitraryValue,
                        '',
                        'none',
                        'gpu',
                        'cpu'
                    ]
                }
            ],
            /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */ 'transform-origin': [
                {
                    origin: scaleOrigin()
                }
            ],
            /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */ 'transform-style': [
                {
                    transform: [
                        '3d',
                        'flat'
                    ]
                }
            ],
            /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */ translate: [
                {
                    translate: scaleTranslate()
                }
            ],
            /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-x': [
                {
                    'translate-x': scaleTranslate()
                }
            ],
            /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-y': [
                {
                    'translate-y': scaleTranslate()
                }
            ],
            /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-z': [
                {
                    'translate-z': scaleTranslate()
                }
            ],
            /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-none': [
                'translate-none'
            ],
            // ---------------------
            // --- Interactivity ---
            // ---------------------
            /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */ accent: [
                {
                    accent: scaleColor()
                }
            ],
            /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */ appearance: [
                {
                    appearance: [
                        'none',
                        'auto'
                    ]
                }
            ],
            /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */ 'caret-color': [
                {
                    caret: scaleColor()
                }
            ],
            /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */ 'color-scheme': [
                {
                    scheme: [
                        'normal',
                        'dark',
                        'light',
                        'light-dark',
                        'only-dark',
                        'only-light'
                    ]
                }
            ],
            /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */ cursor: [
                {
                    cursor: [
                        'auto',
                        'default',
                        'pointer',
                        'wait',
                        'text',
                        'move',
                        'help',
                        'not-allowed',
                        'none',
                        'context-menu',
                        'progress',
                        'cell',
                        'crosshair',
                        'vertical-text',
                        'alias',
                        'copy',
                        'no-drop',
                        'grab',
                        'grabbing',
                        'all-scroll',
                        'col-resize',
                        'row-resize',
                        'n-resize',
                        'e-resize',
                        's-resize',
                        'w-resize',
                        'ne-resize',
                        'nw-resize',
                        'se-resize',
                        'sw-resize',
                        'ew-resize',
                        'ns-resize',
                        'nesw-resize',
                        'nwse-resize',
                        'zoom-in',
                        'zoom-out',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */ 'field-sizing': [
                {
                    'field-sizing': [
                        'fixed',
                        'content'
                    ]
                }
            ],
            /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */ 'pointer-events': [
                {
                    'pointer-events': [
                        'auto',
                        'none'
                    ]
                }
            ],
            /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */ resize: [
                {
                    resize: [
                        'none',
                        '',
                        'y',
                        'x'
                    ]
                }
            ],
            /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */ 'scroll-behavior': [
                {
                    scroll: [
                        'auto',
                        'smooth'
                    ]
                }
            ],
            /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-m': [
                {
                    'scroll-m': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mx': [
                {
                    'scroll-mx': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-my': [
                {
                    'scroll-my': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ms': [
                {
                    'scroll-ms': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-me': [
                {
                    'scroll-me': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mt': [
                {
                    'scroll-mt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mr': [
                {
                    'scroll-mr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mb': [
                {
                    'scroll-mb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ml': [
                {
                    'scroll-ml': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-p': [
                {
                    'scroll-p': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-px': [
                {
                    'scroll-px': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-py': [
                {
                    'scroll-py': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-ps': [
                {
                    'scroll-ps': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pe': [
                {
                    'scroll-pe': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pt': [
                {
                    'scroll-pt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pr': [
                {
                    'scroll-pr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pb': [
                {
                    'scroll-pb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pl': [
                {
                    'scroll-pl': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */ 'snap-align': [
                {
                    snap: [
                        'start',
                        'end',
                        'center',
                        'align-none'
                    ]
                }
            ],
            /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */ 'snap-stop': [
                {
                    snap: [
                        'normal',
                        'always'
                    ]
                }
            ],
            /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-type': [
                {
                    snap: [
                        'none',
                        'x',
                        'y',
                        'both'
                    ]
                }
            ],
            /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-strictness': [
                {
                    snap: [
                        'mandatory',
                        'proximity'
                    ]
                }
            ],
            /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */ touch: [
                {
                    touch: [
                        'auto',
                        'none',
                        'manipulation'
                    ]
                }
            ],
            /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-x': [
                {
                    'touch-pan': [
                        'x',
                        'left',
                        'right'
                    ]
                }
            ],
            /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-y': [
                {
                    'touch-pan': [
                        'y',
                        'up',
                        'down'
                    ]
                }
            ],
            /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-pz': [
                'touch-pinch-zoom'
            ],
            /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */ select: [
                {
                    select: [
                        'none',
                        'text',
                        'all',
                        'auto'
                    ]
                }
            ],
            /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */ 'will-change': [
                {
                    'will-change': [
                        'auto',
                        'scroll',
                        'contents',
                        'transform',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -----------
            // --- SVG ---
            // -----------
            /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */ fill: [
                {
                    fill: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */ 'stroke-w': [
                {
                    stroke: [
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */ stroke: [
                {
                    stroke: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            // ---------------------
            // --- Accessibility ---
            // ---------------------
            /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */ 'forced-color-adjust': [
                {
                    'forced-color-adjust': [
                        'auto',
                        'none'
                    ]
                }
            ]
        },
        conflictingClassGroups: {
            overflow: [
                'overflow-x',
                'overflow-y'
            ],
            overscroll: [
                'overscroll-x',
                'overscroll-y'
            ],
            inset: [
                'inset-x',
                'inset-y',
                'start',
                'end',
                'top',
                'right',
                'bottom',
                'left'
            ],
            'inset-x': [
                'right',
                'left'
            ],
            'inset-y': [
                'top',
                'bottom'
            ],
            flex: [
                'basis',
                'grow',
                'shrink'
            ],
            gap: [
                'gap-x',
                'gap-y'
            ],
            p: [
                'px',
                'py',
                'ps',
                'pe',
                'pt',
                'pr',
                'pb',
                'pl'
            ],
            px: [
                'pr',
                'pl'
            ],
            py: [
                'pt',
                'pb'
            ],
            m: [
                'mx',
                'my',
                'ms',
                'me',
                'mt',
                'mr',
                'mb',
                'ml'
            ],
            mx: [
                'mr',
                'ml'
            ],
            my: [
                'mt',
                'mb'
            ],
            size: [
                'w',
                'h'
            ],
            'font-size': [
                'leading'
            ],
            'fvn-normal': [
                'fvn-ordinal',
                'fvn-slashed-zero',
                'fvn-figure',
                'fvn-spacing',
                'fvn-fraction'
            ],
            'fvn-ordinal': [
                'fvn-normal'
            ],
            'fvn-slashed-zero': [
                'fvn-normal'
            ],
            'fvn-figure': [
                'fvn-normal'
            ],
            'fvn-spacing': [
                'fvn-normal'
            ],
            'fvn-fraction': [
                'fvn-normal'
            ],
            'line-clamp': [
                'display',
                'overflow'
            ],
            rounded: [
                'rounded-s',
                'rounded-e',
                'rounded-t',
                'rounded-r',
                'rounded-b',
                'rounded-l',
                'rounded-ss',
                'rounded-se',
                'rounded-ee',
                'rounded-es',
                'rounded-tl',
                'rounded-tr',
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-s': [
                'rounded-ss',
                'rounded-es'
            ],
            'rounded-e': [
                'rounded-se',
                'rounded-ee'
            ],
            'rounded-t': [
                'rounded-tl',
                'rounded-tr'
            ],
            'rounded-r': [
                'rounded-tr',
                'rounded-br'
            ],
            'rounded-b': [
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-l': [
                'rounded-tl',
                'rounded-bl'
            ],
            'border-spacing': [
                'border-spacing-x',
                'border-spacing-y'
            ],
            'border-w': [
                'border-w-s',
                'border-w-e',
                'border-w-t',
                'border-w-r',
                'border-w-b',
                'border-w-l'
            ],
            'border-w-x': [
                'border-w-r',
                'border-w-l'
            ],
            'border-w-y': [
                'border-w-t',
                'border-w-b'
            ],
            'border-color': [
                'border-color-s',
                'border-color-e',
                'border-color-t',
                'border-color-r',
                'border-color-b',
                'border-color-l'
            ],
            'border-color-x': [
                'border-color-r',
                'border-color-l'
            ],
            'border-color-y': [
                'border-color-t',
                'border-color-b'
            ],
            translate: [
                'translate-x',
                'translate-y',
                'translate-none'
            ],
            'translate-none': [
                'translate',
                'translate-x',
                'translate-y',
                'translate-z'
            ],
            'scroll-m': [
                'scroll-mx',
                'scroll-my',
                'scroll-ms',
                'scroll-me',
                'scroll-mt',
                'scroll-mr',
                'scroll-mb',
                'scroll-ml'
            ],
            'scroll-mx': [
                'scroll-mr',
                'scroll-ml'
            ],
            'scroll-my': [
                'scroll-mt',
                'scroll-mb'
            ],
            'scroll-p': [
                'scroll-px',
                'scroll-py',
                'scroll-ps',
                'scroll-pe',
                'scroll-pt',
                'scroll-pr',
                'scroll-pb',
                'scroll-pl'
            ],
            'scroll-px': [
                'scroll-pr',
                'scroll-pl'
            ],
            'scroll-py': [
                'scroll-pt',
                'scroll-pb'
            ],
            touch: [
                'touch-x',
                'touch-y',
                'touch-pz'
            ],
            'touch-x': [
                'touch'
            ],
            'touch-y': [
                'touch'
            ],
            'touch-pz': [
                'touch'
            ]
        },
        conflictingClassGroupModifiers: {
            'font-size': [
                'leading'
            ]
        },
        orderSensitiveModifiers: [
            'before',
            'after',
            'placeholder',
            'file',
            'marker',
            'selection',
            'first-line',
            'first-letter',
            'backdrop',
            '*',
            '**'
        ]
    };
};
/**
 * @param baseConfig Config where other config will be merged into. This object will be mutated.
 * @param configExtension Partial config to merge into the `baseConfig`.
 */ const mergeConfigs = (baseConfig, { cacheSize, prefix, experimentalParseClassName, extend = {}, override = {} })=>{
    overrideProperty(baseConfig, 'cacheSize', cacheSize);
    overrideProperty(baseConfig, 'prefix', prefix);
    overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);
    overrideConfigProperties(baseConfig.theme, override.theme);
    overrideConfigProperties(baseConfig.classGroups, override.classGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
    overrideProperty(baseConfig, 'orderSensitiveModifiers', override.orderSensitiveModifiers);
    mergeConfigProperties(baseConfig.theme, extend.theme);
    mergeConfigProperties(baseConfig.classGroups, extend.classGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers);
    mergeArrayProperties(baseConfig, extend, 'orderSensitiveModifiers');
    return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue)=>{
    if (overrideValue !== undefined) {
        baseObject[overrideKey] = overrideValue;
    }
};
const overrideConfigProperties = (baseObject, overrideObject)=>{
    if (overrideObject) {
        for(const key in overrideObject){
            overrideProperty(baseObject, key, overrideObject[key]);
        }
    }
};
const mergeConfigProperties = (baseObject, mergeObject)=>{
    if (mergeObject) {
        for(const key in mergeObject){
            mergeArrayProperties(baseObject, mergeObject, key);
        }
    }
};
const mergeArrayProperties = (baseObject, mergeObject, key)=>{
    const mergeValue = mergeObject[key];
    if (mergeValue !== undefined) {
        baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
    }
};
const extendTailwindMerge = (configExtension, ...createConfig)=>typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(()=>mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig);
;
 //# sourceMappingURL=bundle-mjs.mjs.map
}}),
"[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// packages/react/compose-refs/src/composeRefs.tsx
__turbopack_esm__({
    "composeRefs": (()=>composeRefs),
    "useComposedRefs": (()=>useComposedRefs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.useCallback(composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@radix-ui/react-slot/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// packages/react/slot/src/slot.tsx
__turbopack_esm__({
    "Root": (()=>Root),
    "Slot": (()=>Slot),
    "Slottable": (()=>Slottable)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-ssr] (ecmascript)");
;
;
;
var Slot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
    const { children, ...slotProps } = props;
    const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
        const newElement = slottable.props.children;
        const newChildren = childrenArray.map((child)=>{
            if (child === slottable) {
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Children.count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Children.only(null);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? newElement.props.children : null;
            } else {
                return child;
            }
        });
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.cloneElement(newElement, void 0, newChildren) : null
        });
    }
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
        ...slotProps,
        ref: forwardedRef,
        children
    });
});
Slot.displayName = "Slot";
var SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
    const { children, ...slotProps } = props;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isValidElement(children)) {
        const childrenRef = getElementRef(children);
        const props2 = mergeProps(slotProps, children.props);
        if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Fragment) {
            props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.cloneElement(children, props2);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Children.count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children })=>{
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fragment"], {
        children
    });
};
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    childPropValue(...args);
                    slotPropValue(...args);
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
var Root = Slot;
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@11labs/client/dist/lib.modern.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "Conversation": (()=>f),
    "postOverallFeedback": (()=>g)
});
function e() {
    return e = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined), e.apply(null, arguments);
}
function t(e) {
    const t = new Uint8Array(e);
    return window.btoa(String.fromCharCode(...t));
}
function n(e) {
    const t = window.atob(e), n = t.length, a = new Uint8Array(n);
    for(let e = 0; e < n; e++)a[e] = t.charCodeAt(e);
    return a.buffer;
}
const a = new Blob([
    '\n      const BIAS = 0x84;\n      const CLIP = 32635;\n      const encodeTable = [\n        0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n        4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n        5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n      ];\n      \n      function encodeSample(sample) {\n        let sign;\n        let exponent;\n        let mantissa;\n        let muLawSample;\n        sign = (sample >> 8) & 0x80;\n        if (sign !== 0) sample = -sample;\n        sample = sample + BIAS;\n        if (sample > CLIP) sample = CLIP;\n        exponent = encodeTable[(sample>>7) & 0xFF];\n        mantissa = (sample >> (exponent+3)) & 0x0F;\n        muLawSample = ~(sign | (exponent << 4) | mantissa);\n        \n        return muLawSample;\n      }\n    \n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n                    \n          this.port.onmessage = ({ data }) => {\n            this.buffer = []; // Initialize an empty buffer\n            this.bufferSize = data.sampleRate / 4;\n            \n            if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n              globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n                this.resampler = resampler;\n              });\n            } \n          };\n        }\n        process(inputs) {\n          if (!this.buffer) {\n            return true;\n          }\n          \n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel\'s data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let encodedArray = this.format === "ulaw"\n                ? new Uint8Array(float32Array.length)\n                : new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n                // Scale the sample to the range [-32768, 32767]\n                let value = sample < 0 ? sample * 32768 : sample * 32767;\n                if (this.format === "ulaw") {\n                  value = encodeSample(Math.round(value));\n                }\n\n                encodedArray[i] = value;\n              }\n\n              // Send the buffered data to the main script\n              this.port.postMessage([encodedArray, maxVolume]);\n\n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor("raw-audio-processor", RawAudioProcessor);\n  '
], {
    type: "application/javascript"
}), s = URL.createObjectURL(a);
function o() {
    return [
        "iPad Simulator",
        "iPhone Simulator",
        "iPod Simulator",
        "iPad",
        "iPhone",
        "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
class i {
    static async create({ sampleRate: e, format: t, preferHeadphonesForIosDevices: n }) {
        let a = null, r = null;
        try {
            const l = {
                sampleRate: {
                    ideal: e
                },
                echoCancellation: {
                    ideal: !0
                },
                noiseSuppression: {
                    ideal: !0
                }
            };
            if (o() && n) {
                const e = (await window.navigator.mediaDevices.enumerateDevices()).find((e)=>"audioinput" === e.kind && [
                        "airpod",
                        "headphone",
                        "earphone"
                    ].find((t)=>e.label.toLowerCase().includes(t)));
                e && (l.deviceId = {
                    ideal: e.deviceId
                });
            }
            const c = navigator.mediaDevices.getSupportedConstraints().sampleRate;
            a = new window.AudioContext(c ? {
                sampleRate: e
            } : {});
            const u = a.createAnalyser();
            c || await a.audioWorklet.addModule("https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js"), await a.audioWorklet.addModule(s), r = await navigator.mediaDevices.getUserMedia({
                audio: l
            });
            const d = a.createMediaStreamSource(r), h = new AudioWorkletNode(a, "raw-audio-processor");
            return h.port.postMessage({
                type: "setFormat",
                format: t,
                sampleRate: e
            }), d.connect(u), u.connect(h), await a.resume(), new i(a, u, h, r);
        } catch (e) {
            var l, c;
            throw null == (l = r) || l.getTracks().forEach((e)=>e.stop()), null == (c = a) || c.close(), e;
        }
    }
    constructor(e, t, n, a){
        this.context = void 0, this.analyser = void 0, this.worklet = void 0, this.inputStream = void 0, this.context = e, this.analyser = t, this.worklet = n, this.inputStream = a;
    }
    async close() {
        this.inputStream.getTracks().forEach((e)=>e.stop()), await this.context.close();
    }
}
const r = new Blob([
    '\n      const decodeTable = [0,132,396,924,1980,4092,8316,16764];\n      \n      export function decodeSample(muLawSample) {\n        let sign;\n        let exponent;\n        let mantissa;\n        let sample;\n        muLawSample = ~muLawSample;\n        sign = (muLawSample & 0x80);\n        exponent = (muLawSample >> 4) & 0x07;\n        mantissa = muLawSample & 0x0F;\n        sample = decodeTable[exponent] + (mantissa << (exponent+3));\n        if (sign !== 0) sample = -sample;\n\n        return sample;\n      }\n      \n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n          \n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case "setFormat":\n                this.format = data.format;\n                break;\n              case "buffer":\n                this.wasInterrupted = false;\n                this.buffers.push(\n                  this.format === "ulaw"\n                    ? new Uint8Array(data.buffer)\n                    : new Int16Array(data.buffer)\n                );\n                break;\n              case "interrupt":\n                this.wasInterrupted = true;\n                break;\n              case "clearInterrupted":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            let value = this.currentBuffer[this.cursor];\n            if (this.format === "ulaw") {\n              value = decodeSample(value);\n            }\n            output[i] = value / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: "process", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor("audio-concat-processor", AudioConcatProcessor);\n    '
], {
    type: "application/javascript"
}), l = URL.createObjectURL(r);
class c {
    static async create({ sampleRate: e, format: t }) {
        let n = null;
        try {
            n = new AudioContext({
                sampleRate: e
            });
            const a = n.createAnalyser(), s = n.createGain();
            s.connect(a), a.connect(n.destination), await n.audioWorklet.addModule(l);
            const o = new AudioWorkletNode(n, "audio-concat-processor");
            return o.port.postMessage({
                type: "setFormat",
                format: t
            }), o.connect(s), await n.resume(), new c(n, a, s, o);
        } catch (e) {
            var a;
            throw null == (a = n) || a.close(), e;
        }
    }
    constructor(e, t, n, a){
        this.context = void 0, this.analyser = void 0, this.gain = void 0, this.worklet = void 0, this.context = e, this.analyser = t, this.gain = n, this.worklet = a;
    }
    async close() {
        await this.context.close();
    }
}
function u(e) {
    return !!e.type;
}
class d {
    static async create(e) {
        let t = null;
        try {
            var n;
            const a = null != (n = e.origin) ? n : "wss://api.elevenlabs.io", s = e.signedUrl ? e.signedUrl : a + "/v1/convai/conversation?agent_id=" + e.agentId, o = [
                "convai"
            ];
            e.authorization && o.push(`bearer.${e.authorization}`), t = new WebSocket(s, o);
            const i = await new Promise((n, a)=>{
                t.addEventListener("open", ()=>{
                    var n;
                    const a = {
                        type: "conversation_initiation_client_data"
                    };
                    var s, o, i, r;
                    e.overrides && (a.conversation_config_override = {
                        agent: {
                            prompt: null == (s = e.overrides.agent) ? void 0 : s.prompt,
                            first_message: null == (o = e.overrides.agent) ? void 0 : o.firstMessage,
                            language: null == (i = e.overrides.agent) ? void 0 : i.language
                        },
                        tts: {
                            voice_id: null == (r = e.overrides.tts) ? void 0 : r.voiceId
                        }
                    }), e.customLlmExtraBody && (a.custom_llm_extra_body = e.customLlmExtraBody), e.dynamicVariables && (a.dynamic_variables = e.dynamicVariables), null == (n = t) || n.send(JSON.stringify(a));
                }, {
                    once: !0
                }), t.addEventListener("error", (e)=>{
                    setTimeout(()=>a(e), 0);
                }), t.addEventListener("close", a), t.addEventListener("message", (e)=>{
                    const t = JSON.parse(e.data);
                    u(t) && ("conversation_initiation_metadata" === t.type ? n(t.conversation_initiation_metadata_event) : console.warn("First received message is not conversation metadata."));
                }, {
                    once: !0
                });
            }), { conversation_id: r, agent_output_audio_format: l, user_input_audio_format: c } = i, p = h(null != c ? c : "pcm_16000"), m = h(l);
            return new d(t, r, p, m);
        } catch (e) {
            var a;
            throw null == (a = t) || a.close(), e;
        }
    }
    constructor(e, t, n, a){
        this.socket = void 0, this.conversationId = void 0, this.inputFormat = void 0, this.outputFormat = void 0, this.queue = [], this.disconnectionDetails = null, this.onDisconnectCallback = null, this.onMessageCallback = null, this.socket = e, this.conversationId = t, this.inputFormat = n, this.outputFormat = a, this.socket.addEventListener("error", (e)=>{
            setTimeout(()=>this.disconnect({
                    reason: "error",
                    message: "The connection was closed due to a socket error.",
                    context: e
                }), 0);
        }), this.socket.addEventListener("close", (e)=>{
            this.disconnect(1e3 === e.code ? {
                reason: "agent",
                context: e
            } : {
                reason: "error",
                message: e.reason || "The connection was closed by the server.",
                context: e
            });
        }), this.socket.addEventListener("message", (e)=>{
            try {
                const t = JSON.parse(e.data);
                if (!u(t)) return;
                this.onMessageCallback ? this.onMessageCallback(t) : this.queue.push(t);
            } catch (e) {}
        });
    }
    close() {
        this.socket.close();
    }
    sendMessage(e) {
        this.socket.send(JSON.stringify(e));
    }
    onMessage(e) {
        this.onMessageCallback = e, this.queue.forEach(e), this.queue = [];
    }
    onDisconnect(e) {
        this.onDisconnectCallback = e, this.disconnectionDetails && e(this.disconnectionDetails);
    }
    disconnect(e) {
        var t;
        this.disconnectionDetails || (this.disconnectionDetails = e, null == (t = this.onDisconnectCallback) || t.call(this, e));
    }
}
function h(e) {
    const [t, n] = e.split("_");
    if (![
        "pcm",
        "ulaw"
    ].includes(t)) throw new Error(`Invalid format: ${e}`);
    const a = parseInt(n);
    if (isNaN(a)) throw new Error(`Invalid sample rate: ${n}`);
    return {
        format: t,
        sampleRate: a
    };
}
const p = {
    clientTools: {}
}, m = {
    onConnect: ()=>{},
    onDebug: ()=>{},
    onDisconnect: ()=>{},
    onError: ()=>{},
    onMessage: ()=>{},
    onModeChange: ()=>{},
    onStatusChange: ()=>{},
    onCanSendFeedbackChange: ()=>{}
};
class f {
    static async startSession(t) {
        const n = e({}, p, m, t);
        n.onStatusChange({
            status: "connecting"
        }), n.onCanSendFeedbackChange({
            canSendFeedback: !1
        });
        let a = null, s = null, r = null, l = null;
        try {
            var u, h;
            l = await navigator.mediaDevices.getUserMedia({
                audio: !0
            });
            const p = null != (u = t.connectionDelay) ? u : {
                default: 0,
                android: 3e3
            };
            let m = p.default;
            var g;
            if (/android/i.test(navigator.userAgent)) m = null != (g = p.android) ? g : m;
            else if (o()) {
                var v;
                m = null != (v = p.ios) ? v : m;
            }
            return m > 0 && await new Promise((e)=>setTimeout(e, m)), s = await d.create(t), [a, r] = await Promise.all([
                i.create(e({}, s.inputFormat, {
                    preferHeadphonesForIosDevices: t.preferHeadphonesForIosDevices
                })),
                c.create(s.outputFormat)
            ]), null == (h = l) || h.getTracks().forEach((e)=>e.stop()), l = null, new f(n, s, a, r);
        } catch (e) {
            var _, y, w, b;
            throw n.onStatusChange({
                status: "disconnected"
            }), null == (_ = l) || _.getTracks().forEach((e)=>e.stop()), null == (y = s) || y.close(), await (null == (w = a) ? void 0 : w.close()), await (null == (b = r) ? void 0 : b.close()), e;
        }
    }
    constructor(e, a, s, o){
        var i = this;
        this.options = void 0, this.connection = void 0, this.input = void 0, this.output = void 0, this.lastInterruptTimestamp = 0, this.mode = "listening", this.status = "connecting", this.inputFrequencyData = void 0, this.outputFrequencyData = void 0, this.volume = 1, this.currentEventId = 1, this.lastFeedbackEventId = 1, this.canSendFeedback = !1, this.endSession = ()=>this.endSessionWithDetails({
                reason: "user"
            }), this.endSessionWithDetails = async function(e) {
            "connected" !== i.status && "connecting" !== i.status || (i.updateStatus("disconnecting"), i.connection.close(), await i.input.close(), await i.output.close(), i.updateStatus("disconnected"), i.options.onDisconnect(e));
        }, this.updateMode = (e)=>{
            e !== this.mode && (this.mode = e, this.options.onModeChange({
                mode: e
            }));
        }, this.updateStatus = (e)=>{
            e !== this.status && (this.status = e, this.options.onStatusChange({
                status: e
            }));
        }, this.updateCanSendFeedback = ()=>{
            const e = this.currentEventId !== this.lastFeedbackEventId;
            this.canSendFeedback !== e && (this.canSendFeedback = e, this.options.onCanSendFeedbackChange({
                canSendFeedback: e
            }));
        }, this.onMessage = async function(e) {
            switch(e.type){
                case "interruption":
                    e.interruption_event && (i.lastInterruptTimestamp = e.interruption_event.event_id), i.fadeOutAudio();
                    break;
                case "agent_response":
                    i.options.onMessage({
                        source: "ai",
                        message: e.agent_response_event.agent_response
                    });
                    break;
                case "user_transcript":
                    i.options.onMessage({
                        source: "user",
                        message: e.user_transcription_event.user_transcript
                    });
                    break;
                case "internal_tentative_agent_response":
                    i.options.onDebug({
                        type: "tentative_agent_response",
                        response: e.tentative_agent_response_internal_event.tentative_agent_response
                    });
                    break;
                case "client_tool_call":
                    if (i.options.clientTools.hasOwnProperty(e.client_tool_call.tool_name)) {
                        try {
                            var t;
                            const n = null != (t = await i.options.clientTools[e.client_tool_call.tool_name](e.client_tool_call.parameters)) ? t : "Client tool execution successful.";
                            i.connection.sendMessage({
                                type: "client_tool_result",
                                tool_call_id: e.client_tool_call.tool_call_id,
                                result: n,
                                is_error: !1
                            });
                        } catch (t) {
                            i.onError("Client tool execution failed with following error: " + (null == t ? void 0 : t.message), {
                                clientToolName: e.client_tool_call.tool_name
                            }), i.connection.sendMessage({
                                type: "client_tool_result",
                                tool_call_id: e.client_tool_call.tool_call_id,
                                result: "Client tool execution failed: " + (null == t ? void 0 : t.message),
                                is_error: !0
                            });
                        }
                        break;
                    }
                    if (i.options.onUnhandledClientToolCall) {
                        i.options.onUnhandledClientToolCall(e.client_tool_call);
                        break;
                    }
                    i.onError(`Client tool with name ${e.client_tool_call.tool_name} is not defined on client`, {
                        clientToolName: e.client_tool_call.tool_name
                    }), i.connection.sendMessage({
                        type: "client_tool_result",
                        tool_call_id: e.client_tool_call.tool_call_id,
                        result: `Client tool with name ${e.client_tool_call.tool_name} is not defined on client`,
                        is_error: !0
                    });
                    break;
                case "audio":
                    i.lastInterruptTimestamp <= e.audio_event.event_id && (i.addAudioBase64Chunk(e.audio_event.audio_base_64), i.currentEventId = e.audio_event.event_id, i.updateCanSendFeedback(), i.updateMode("speaking"));
                    break;
                case "ping":
                    i.connection.sendMessage({
                        type: "pong",
                        event_id: e.ping_event.event_id
                    });
                    break;
                default:
                    i.options.onDebug(e);
            }
        }, this.onInputWorkletMessage = (e)=>{
            "connected" === this.status && this.connection.sendMessage({
                user_audio_chunk: t(e.data[0].buffer)
            });
        }, this.onOutputWorkletMessage = ({ data: e })=>{
            "process" === e.type && this.updateMode(e.finished ? "listening" : "speaking");
        }, this.addAudioBase64Chunk = (e)=>{
            this.output.gain.gain.value = this.volume, this.output.worklet.port.postMessage({
                type: "clearInterrupted"
            }), this.output.worklet.port.postMessage({
                type: "buffer",
                buffer: n(e)
            });
        }, this.fadeOutAudio = ()=>{
            this.updateMode("listening"), this.output.worklet.port.postMessage({
                type: "interrupt"
            }), this.output.gain.gain.exponentialRampToValueAtTime(1e-4, this.output.context.currentTime + 2), setTimeout(()=>{
                this.output.gain.gain.value = this.volume, this.output.worklet.port.postMessage({
                    type: "clearInterrupted"
                });
            }, 2e3);
        }, this.onError = (e, t)=>{
            console.error(e, t), this.options.onError(e, t);
        }, this.calculateVolume = (e)=>{
            if (0 === e.length) return 0;
            let t = 0;
            for(let n = 0; n < e.length; n++)t += e[n] / 255;
            return t /= e.length, t < 0 ? 0 : t > 1 ? 1 : t;
        }, this.getId = ()=>this.connection.conversationId, this.isOpen = ()=>"connected" === this.status, this.setVolume = ({ volume: e })=>{
            this.volume = e;
        }, this.getInputByteFrequencyData = ()=>(null != this.inputFrequencyData || (this.inputFrequencyData = new Uint8Array(this.input.analyser.frequencyBinCount)), this.input.analyser.getByteFrequencyData(this.inputFrequencyData), this.inputFrequencyData), this.getOutputByteFrequencyData = ()=>(null != this.outputFrequencyData || (this.outputFrequencyData = new Uint8Array(this.output.analyser.frequencyBinCount)), this.output.analyser.getByteFrequencyData(this.outputFrequencyData), this.outputFrequencyData), this.getInputVolume = ()=>this.calculateVolume(this.getInputByteFrequencyData()), this.getOutputVolume = ()=>this.calculateVolume(this.getOutputByteFrequencyData()), this.sendFeedback = (e)=>{
            this.canSendFeedback ? (this.connection.sendMessage({
                type: "feedback",
                score: e ? "like" : "dislike",
                event_id: this.currentEventId
            }), this.lastFeedbackEventId = this.currentEventId, this.updateCanSendFeedback()) : console.warn(0 === this.lastFeedbackEventId ? "Cannot send feedback: the conversation has not started yet." : "Cannot send feedback: feedback has already been sent for the current response.");
        }, this.options = e, this.connection = a, this.input = s, this.output = o, this.options.onConnect({
            conversationId: a.conversationId
        }), this.connection.onDisconnect(this.endSessionWithDetails), this.connection.onMessage(this.onMessage), this.input.worklet.port.onmessage = this.onInputWorkletMessage, this.output.worklet.port.onmessage = this.onOutputWorkletMessage, this.updateStatus("connected");
    }
}
function g(e, t, n = "https://api.elevenlabs.io") {
    return fetch(`${n}/v1/convai/conversations/${e}/feedback`, {
        method: "POST",
        body: JSON.stringify({
            feedback: t ? "like" : "dislike"
        }),
        headers: {
            "Content-Type": "application/json"
        }
    });
}
;
 //# sourceMappingURL=lib.modern.js.map
}}),
"[project]/node_modules/next/script.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/next/dist/client/script.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**!
 * audioMotion-analyzer
 * High-resolution real-time graphic audio spectrum analyzer JS module
 *
 * @version 4.5.0
 * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>
 * @license AGPL-3.0-or-later
 */ __turbopack_esm__({
    "AudioMotionAnalyzer": (()=>AudioMotionAnalyzer),
    "default": (()=>__TURBOPACK__default__export__)
});
const VERSION = '4.5.0';
// internal constants
const PI = Math.PI, TAU = 2 * PI, HALF_PI = PI / 2, C_1 = 8.17579892; // frequency for C -1
const CANVAS_BACKGROUND_COLOR = '#000', CHANNEL_COMBINED = 'dual-combined', CHANNEL_HORIZONTAL = 'dual-horizontal', CHANNEL_SINGLE = 'single', CHANNEL_VERTICAL = 'dual-vertical', COLOR_BAR_INDEX = 'bar-index', COLOR_BAR_LEVEL = 'bar-level', COLOR_GRADIENT = 'gradient', DEBOUNCE_TIMEOUT = 60, EVENT_CLICK = 'click', EVENT_FULLSCREENCHANGE = 'fullscreenchange', EVENT_RESIZE = 'resize', GRADIENT_DEFAULT_BGCOLOR = '#111', FILTER_NONE = '', FILTER_A = 'A', FILTER_B = 'B', FILTER_C = 'C', FILTER_D = 'D', FILTER_468 = '468', FONT_FAMILY = 'sans-serif', FPS_COLOR = '#0f0', LEDS_UNLIT_COLOR = '#7f7f7f22', MODE_GRAPH = 10, REASON_CREATE = 'create', REASON_FSCHANGE = 'fschange', REASON_LORES = 'lores', REASON_RESIZE = EVENT_RESIZE, REASON_USER = 'user', SCALEX_BACKGROUND_COLOR = '#000c', SCALEX_LABEL_COLOR = '#fff', SCALEX_HIGHLIGHT_COLOR = '#4f4', SCALEY_LABEL_COLOR = '#888', SCALEY_MIDLINE_COLOR = '#555', SCALE_BARK = 'bark', SCALE_LINEAR = 'linear', SCALE_LOG = 'log', SCALE_MEL = 'mel';
// built-in gradients
const PRISM = [
    '#a35',
    '#c66',
    '#e94',
    '#ed0',
    '#9d5',
    '#4d8',
    '#2cb',
    '#0bc',
    '#09c',
    '#36b'
], GRADIENTS = [
    [
        'classic',
        {
            colorStops: [
                'red',
                {
                    color: 'yellow',
                    level: .85,
                    pos: .6
                },
                {
                    color: 'lime',
                    level: .475
                }
            ]
        }
    ],
    [
        'prism',
        {
            colorStops: PRISM
        }
    ],
    [
        'rainbow',
        {
            dir: 'h',
            colorStops: [
                '#817',
                ...PRISM,
                '#639'
            ]
        }
    ],
    [
        'orangered',
        {
            bgColor: '#3e2f29',
            colorStops: [
                'OrangeRed'
            ]
        }
    ],
    [
        'steelblue',
        {
            bgColor: '#222c35',
            colorStops: [
                'SteelBlue'
            ]
        }
    ]
];
// settings defaults
const DEFAULT_SETTINGS = {
    alphaBars: false,
    ansiBands: false,
    barSpace: 0.1,
    bgAlpha: 0.7,
    channelLayout: CHANNEL_SINGLE,
    colorMode: COLOR_GRADIENT,
    fadePeaks: false,
    fftSize: 8192,
    fillAlpha: 1,
    frequencyScale: SCALE_LOG,
    gradient: GRADIENTS[0][0],
    gravity: 3.8,
    height: undefined,
    ledBars: false,
    linearAmplitude: false,
    linearBoost: 1,
    lineWidth: 0,
    loRes: false,
    lumiBars: false,
    maxDecibels: -25,
    maxFPS: 0,
    maxFreq: 22000,
    minDecibels: -85,
    minFreq: 20,
    mirror: 0,
    mode: 0,
    noteLabels: false,
    outlineBars: false,
    overlay: false,
    peakFadeTime: 750,
    peakHoldTime: 500,
    peakLine: false,
    radial: false,
    radialInvert: false,
    radius: 0.3,
    reflexAlpha: 0.15,
    reflexBright: 1,
    reflexFit: true,
    reflexRatio: 0,
    roundBars: false,
    showBgColor: true,
    showFPS: false,
    showPeaks: true,
    showScaleX: true,
    showScaleY: false,
    smoothing: 0.5,
    spinSpeed: 0,
    splitGradient: false,
    start: true,
    trueLeds: false,
    useCanvas: true,
    volume: 1,
    weightingFilter: FILTER_NONE,
    width: undefined
};
// custom error messages
const ERR_AUDIO_CONTEXT_FAIL = [
    'ERR_AUDIO_CONTEXT_FAIL',
    'Could not create audio context. Web Audio API not supported?'
], ERR_INVALID_AUDIO_CONTEXT = [
    'ERR_INVALID_AUDIO_CONTEXT',
    'Provided audio context is not valid'
], ERR_UNKNOWN_GRADIENT = [
    'ERR_UNKNOWN_GRADIENT',
    'Unknown gradient'
], ERR_FREQUENCY_TOO_LOW = [
    'ERR_FREQUENCY_TOO_LOW',
    'Frequency values must be >= 1'
], ERR_INVALID_MODE = [
    'ERR_INVALID_MODE',
    'Invalid mode'
], ERR_REFLEX_OUT_OF_RANGE = [
    'ERR_REFLEX_OUT_OF_RANGE',
    'Reflex ratio must be >= 0 and < 1'
], ERR_INVALID_AUDIO_SOURCE = [
    'ERR_INVALID_AUDIO_SOURCE',
    'Audio source must be an instance of HTMLMediaElement or AudioNode'
], ERR_GRADIENT_INVALID_NAME = [
    'ERR_GRADIENT_INVALID_NAME',
    'Gradient name must be a non-empty string'
], ERR_GRADIENT_NOT_AN_OBJECT = [
    'ERR_GRADIENT_NOT_AN_OBJECT',
    'Gradient options must be an object'
], ERR_GRADIENT_MISSING_COLOR = [
    'ERR_GRADIENT_MISSING_COLOR',
    'Gradient colorStops must be a non-empty array'
];
class AudioMotionError extends Error {
    constructor(error, value){
        const [code, message] = error;
        super(message + (value !== undefined ? `: ${value}` : ''));
        this.name = 'AudioMotionError';
        this.code = code;
    }
}
// helper function - output deprecation warning message on console
const deprecate = (name, alternative)=>console.warn(`${name} is deprecated. Use ${alternative} instead.`);
// helper function - check if a given object is empty (also returns `true` on null, undefined or any non-object value)
const isEmpty = (obj)=>{
    for(const p in obj)return false;
    return true;
};
// helper function - validate a given value with an array of strings (by default, all lowercase)
// returns the validated value, or the first element of `list` if `value` is not found in the array
const validateFromList = (value, list, modifier = 'toLowerCase')=>list[Math.max(0, list.indexOf(('' + value)[modifier]()))];
// helper function - find the Y-coordinate of a point located between two other points, given its X-coordinate
const findY = (x1, y1, x2, y2, x)=>y1 + (y2 - y1) * (x - x1) / (x2 - x1);
// Polyfill for Array.findLastIndex()
if (!Array.prototype.findLastIndex) {
    Array.prototype.findLastIndex = function(callback) {
        let index = this.length;
        while(index-- > 0){
            if (callback(this[index])) return index;
        }
        return -1;
    };
}
// AudioMotionAnalyzer class
class AudioMotionAnalyzer {
    /**
 * CONSTRUCTOR
 *
 * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body
 * @param {object} [options]
 * @returns {object} AudioMotionAnalyzer object
 */ constructor(container, options = {}){
        this._ready = false;
        // Initialize internal objects
        this._aux = {}; // auxiliary variables
        this._canvasGradients = []; // CanvasGradient objects for channels 0 and 1
        this._destroyed = false;
        this._energy = {
            val: 0,
            peak: 0,
            hold: 0
        };
        this._flg = {}; // flags
        this._fps = 0;
        this._gradients = {}; // registered gradients
        this._last = 0; // timestamp of last rendered frame
        this._outNodes = []; // output nodes
        this._ownContext = false;
        this._selectedGrads = []; // names of the currently selected gradients for channels 0 and 1
        this._sources = []; // input nodes
        // Check if options object passed as first argument
        if (!(container instanceof Element)) {
            if (isEmpty(options) && !isEmpty(container)) options = container;
            container = null;
        }
        this._ownCanvas = !(options.canvas instanceof HTMLCanvasElement);
        // Create a new canvas or use the one provided by the user
        const canvas = this._ownCanvas ? document.createElement('canvas') : options.canvas;
        canvas.style = 'max-width: 100%;';
        this._ctx = canvas.getContext('2d');
        // Register built-in gradients
        for (const [name, options] of GRADIENTS)this.registerGradient(name, options);
        // Set container
        this._container = container || !this._ownCanvas && canvas.parentElement || document.body;
        // Make sure we have minimal width and height dimensions in case of an inline container
        this._defaultWidth = this._container.clientWidth || 640;
        this._defaultHeight = this._container.clientHeight || 270;
        // Use audio context provided by user, or create a new one
        let audioCtx;
        if (options.source && (audioCtx = options.source.context)) {
        // get audioContext from provided source audioNode
        } else if (audioCtx = options.audioCtx) {
        // use audioContext provided by user
        } else {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this._ownContext = true;
            } catch (err) {
                throw new AudioMotionError(ERR_AUDIO_CONTEXT_FAIL);
            }
        }
        // make sure audioContext is valid
        if (!audioCtx.createGain) throw new AudioMotionError(ERR_INVALID_AUDIO_CONTEXT);
        /*
			Connection routing:
			===================

			for dual channel layouts:                +--->  analyzer[0]  ---+
		    	                                     |                      |
			(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)
		    	                                     |                      |
		        	                                 +--->  analyzer[1]  ---+

			for single channel layout:

			(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)

		*/ // create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections
        const analyzer = this._analyzer = [
            audioCtx.createAnalyser(),
            audioCtx.createAnalyser()
        ];
        const splitter = this._splitter = audioCtx.createChannelSplitter(2);
        const merger = this._merger = audioCtx.createChannelMerger(2);
        this._input = audioCtx.createGain();
        this._output = audioCtx.createGain();
        // connect audio source if provided in the options
        if (options.source) this.connectInput(options.source);
        // connect splitter -> analyzers
        for (const i of [
            0,
            1
        ])splitter.connect(analyzer[i], i);
        // connect merger -> output
        merger.connect(this._output);
        // connect output -> destination (speakers)
        if (options.connectSpeakers !== false) this.connectOutput();
        // create auxiliary canvases for the X-axis and radial scale labels
        for (const ctx of [
            '_scaleX',
            '_scaleR'
        ])this[ctx] = document.createElement('canvas').getContext('2d');
        // set fullscreen element (defaults to canvas)
        this._fsEl = options.fsElement || canvas;
        // Update canvas size on container / window resize and fullscreen events
        // Fullscreen changes are handled quite differently across browsers:
        // 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`
        // 2. Firefox triggers the `fullscreenchange` first and then the `resize`
        // 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`
        // 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`
        //    event is triggered **on the window** only (last tested on iPadOS 14)
        // helper function for resize events
        const onResize = ()=>{
            if (!this._fsTimeout) {
                // delay the resize to prioritize a possible following `fullscreenchange` event
                this._fsTimeout = window.setTimeout(()=>{
                    if (!this._fsChanging) {
                        this._setCanvas(REASON_RESIZE);
                        this._fsTimeout = 0;
                    }
                }, DEBOUNCE_TIMEOUT);
            }
        };
        // if browser supports ResizeObserver, listen for resize on the container
        if (window.ResizeObserver) {
            this._observer = new ResizeObserver(onResize);
            this._observer.observe(this._container);
        }
        // create an AbortController to remove event listeners on destroy()
        this._controller = new AbortController();
        const signal = this._controller.signal;
        // listen for resize events on the window - required for fullscreen on iPadOS
        window.addEventListener(EVENT_RESIZE, onResize, {
            signal
        });
        // listen for fullscreenchange events on the canvas - not available on Safari
        canvas.addEventListener(EVENT_FULLSCREENCHANGE, ()=>{
            // set flag to indicate a fullscreen change in progress
            this._fsChanging = true;
            // if there is a scheduled resize event, clear it
            if (this._fsTimeout) window.clearTimeout(this._fsTimeout);
            // update the canvas
            this._setCanvas(REASON_FSCHANGE);
            // delay clearing the flag to prevent any shortly following resize event
            this._fsTimeout = window.setTimeout(()=>{
                this._fsChanging = false;
                this._fsTimeout = 0;
            }, DEBOUNCE_TIMEOUT);
        }, {
            signal
        });
        // Resume audio context if in suspended state (browsers' autoplay policy)
        const unlockContext = ()=>{
            if (audioCtx.state == 'suspended') audioCtx.resume();
            window.removeEventListener(EVENT_CLICK, unlockContext);
        };
        window.addEventListener(EVENT_CLICK, unlockContext);
        // reset FPS-related variables when window becomes visible (avoid FPS drop due to frames not rendered while hidden)
        document.addEventListener('visibilitychange', ()=>{
            if (document.visibilityState != 'hidden') {
                this._frames = 0;
                this._time = performance.now();
            }
        }, {
            signal
        });
        // Set configuration options and use defaults for any missing properties
        this._setProps(options, true);
        // Add canvas to the container (only when canvas not provided by user)
        if (this.useCanvas && this._ownCanvas) this._container.appendChild(canvas);
        // Finish canvas setup
        this._ready = true;
        this._setCanvas(REASON_CREATE);
    }
    /**
	 * ==========================================================================
	 *
	 * PUBLIC PROPERTIES GETTERS AND SETTERS
	 *
	 * ==========================================================================
	 */ get alphaBars() {
        return this._alphaBars;
    }
    set alphaBars(value) {
        this._alphaBars = !!value;
        this._calcBars();
    }
    get ansiBands() {
        return this._ansiBands;
    }
    set ansiBands(value) {
        this._ansiBands = !!value;
        this._calcBars();
    }
    get barSpace() {
        return this._barSpace;
    }
    set barSpace(value) {
        this._barSpace = +value || 0;
        this._calcBars();
    }
    get channelLayout() {
        return this._chLayout;
    }
    set channelLayout(value) {
        this._chLayout = validateFromList(value, [
            CHANNEL_SINGLE,
            CHANNEL_HORIZONTAL,
            CHANNEL_VERTICAL,
            CHANNEL_COMBINED
        ]);
        // update node connections
        this._input.disconnect();
        this._input.connect(this._chLayout != CHANNEL_SINGLE ? this._splitter : this._analyzer[0]);
        this._analyzer[0].disconnect();
        if (this._outNodes.length) this._analyzer[0].connect(this._chLayout != CHANNEL_SINGLE ? this._merger : this._output);
        this._calcBars();
        this._makeGrad();
    }
    get colorMode() {
        return this._colorMode;
    }
    set colorMode(value) {
        this._colorMode = validateFromList(value, [
            COLOR_GRADIENT,
            COLOR_BAR_INDEX,
            COLOR_BAR_LEVEL
        ]);
    }
    get fadePeaks() {
        return this._fadePeaks;
    }
    set fadePeaks(value) {
        this._fadePeaks = !!value;
    }
    get fftSize() {
        return this._analyzer[0].fftSize;
    }
    set fftSize(value) {
        for (const i of [
            0,
            1
        ])this._analyzer[i].fftSize = value;
        const binCount = this._analyzer[0].frequencyBinCount;
        this._fftData = [
            new Float32Array(binCount),
            new Float32Array(binCount)
        ];
        this._calcBars();
    }
    get frequencyScale() {
        return this._frequencyScale;
    }
    set frequencyScale(value) {
        this._frequencyScale = validateFromList(value, [
            SCALE_LOG,
            SCALE_BARK,
            SCALE_MEL,
            SCALE_LINEAR
        ]);
        this._calcBars();
    }
    get gradient() {
        return this._selectedGrads[0];
    }
    set gradient(value) {
        this._setGradient(value);
    }
    get gradientLeft() {
        return this._selectedGrads[0];
    }
    set gradientLeft(value) {
        this._setGradient(value, 0);
    }
    get gradientRight() {
        return this._selectedGrads[1];
    }
    set gradientRight(value) {
        this._setGradient(value, 1);
    }
    get gravity() {
        return this._gravity;
    }
    set gravity(value) {
        this._gravity = value > 0 ? +value : this._gravity || DEFAULT_SETTINGS.gravity;
    }
    get height() {
        return this._height;
    }
    set height(h) {
        this._height = h;
        this._setCanvas(REASON_USER);
    }
    get ledBars() {
        return this._showLeds;
    }
    set ledBars(value) {
        this._showLeds = !!value;
        this._calcBars();
    }
    get linearAmplitude() {
        return this._linearAmplitude;
    }
    set linearAmplitude(value) {
        this._linearAmplitude = !!value;
    }
    get linearBoost() {
        return this._linearBoost;
    }
    set linearBoost(value) {
        this._linearBoost = value >= 1 ? +value : 1;
    }
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = +value || 0;
    }
    get loRes() {
        return this._loRes;
    }
    set loRes(value) {
        this._loRes = !!value;
        this._setCanvas(REASON_LORES);
    }
    get lumiBars() {
        return this._lumiBars;
    }
    set lumiBars(value) {
        this._lumiBars = !!value;
        this._calcBars();
        this._makeGrad();
    }
    get maxDecibels() {
        return this._analyzer[0].maxDecibels;
    }
    set maxDecibels(value) {
        for (const i of [
            0,
            1
        ])this._analyzer[i].maxDecibels = value;
    }
    get maxFPS() {
        return this._maxFPS;
    }
    set maxFPS(value) {
        this._maxFPS = value < 0 ? 0 : +value || 0;
    }
    get maxFreq() {
        return this._maxFreq;
    }
    set maxFreq(value) {
        if (value < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);
        else {
            this._maxFreq = Math.min(value, this.audioCtx.sampleRate / 2);
            this._calcBars();
        }
    }
    get minDecibels() {
        return this._analyzer[0].minDecibels;
    }
    set minDecibels(value) {
        for (const i of [
            0,
            1
        ])this._analyzer[i].minDecibels = value;
    }
    get minFreq() {
        return this._minFreq;
    }
    set minFreq(value) {
        if (value < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);
        else {
            this._minFreq = +value;
            this._calcBars();
        }
    }
    get mirror() {
        return this._mirror;
    }
    set mirror(value) {
        this._mirror = Math.sign(value) | 0; // ensure only -1, 0 or 1
        this._calcBars();
        this._makeGrad();
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        const mode = value | 0;
        if (mode >= 0 && mode <= 10 && mode != 9) {
            this._mode = mode;
            this._calcBars();
            this._makeGrad();
        } else throw new AudioMotionError(ERR_INVALID_MODE, value);
    }
    get noteLabels() {
        return this._noteLabels;
    }
    set noteLabels(value) {
        this._noteLabels = !!value;
        this._createScales();
    }
    get outlineBars() {
        return this._outlineBars;
    }
    set outlineBars(value) {
        this._outlineBars = !!value;
        this._calcBars();
    }
    get peakFadeTime() {
        return this._peakFadeTime;
    }
    set peakFadeTime(value) {
        this._peakFadeTime = value >= 0 ? +value : this._peakFadeTime || DEFAULT_SETTINGS.peakFadeTime;
    }
    get peakHoldTime() {
        return this._peakHoldTime;
    }
    set peakHoldTime(value) {
        this._peakHoldTime = +value || 0;
    }
    get peakLine() {
        return this._peakLine;
    }
    set peakLine(value) {
        this._peakLine = !!value;
    }
    get radial() {
        return this._radial;
    }
    set radial(value) {
        this._radial = !!value;
        this._calcBars();
        this._makeGrad();
    }
    get radialInvert() {
        return this._radialInvert;
    }
    set radialInvert(value) {
        this._radialInvert = !!value;
        this._calcBars();
        this._makeGrad();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = +value || 0;
        this._calcBars();
        this._makeGrad();
    }
    get reflexRatio() {
        return this._reflexRatio;
    }
    set reflexRatio(value) {
        value = +value || 0;
        if (value < 0 || value >= 1) throw new AudioMotionError(ERR_REFLEX_OUT_OF_RANGE);
        else {
            this._reflexRatio = value;
            this._calcBars();
            this._makeGrad();
        }
    }
    get roundBars() {
        return this._roundBars;
    }
    set roundBars(value) {
        this._roundBars = !!value;
        this._calcBars();
    }
    get smoothing() {
        return this._analyzer[0].smoothingTimeConstant;
    }
    set smoothing(value) {
        for (const i of [
            0,
            1
        ])this._analyzer[i].smoothingTimeConstant = value;
    }
    get spinSpeed() {
        return this._spinSpeed;
    }
    set spinSpeed(value) {
        value = +value || 0;
        if (this._spinSpeed === undefined || value == 0) this._spinAngle = -HALF_PI; // initialize or reset the rotation angle
        this._spinSpeed = value;
    }
    get splitGradient() {
        return this._splitGradient;
    }
    set splitGradient(value) {
        this._splitGradient = !!value;
        this._makeGrad();
    }
    get stereo() {
        deprecate('stereo', 'channelLayout');
        return this._chLayout != CHANNEL_SINGLE;
    }
    set stereo(value) {
        deprecate('stereo', 'channelLayout');
        this.channelLayout = value ? CHANNEL_VERTICAL : CHANNEL_SINGLE;
    }
    get trueLeds() {
        return this._trueLeds;
    }
    set trueLeds(value) {
        this._trueLeds = !!value;
    }
    get volume() {
        return this._output.gain.value;
    }
    set volume(value) {
        this._output.gain.value = value;
    }
    get weightingFilter() {
        return this._weightingFilter;
    }
    set weightingFilter(value) {
        this._weightingFilter = validateFromList(value, [
            FILTER_NONE,
            FILTER_A,
            FILTER_B,
            FILTER_C,
            FILTER_D,
            FILTER_468
        ], 'toUpperCase');
    }
    get width() {
        return this._width;
    }
    set width(w) {
        this._width = w;
        this._setCanvas(REASON_USER);
    }
    // Read only properties
    get audioCtx() {
        return this._input.context;
    }
    get canvas() {
        return this._ctx.canvas;
    }
    get canvasCtx() {
        return this._ctx;
    }
    get connectedSources() {
        return this._sources;
    }
    get connectedTo() {
        return this._outNodes;
    }
    get fps() {
        return this._fps;
    }
    get fsHeight() {
        return this._fsHeight;
    }
    get fsWidth() {
        return this._fsWidth;
    }
    get isAlphaBars() {
        return this._flg.isAlpha;
    }
    get isBandsMode() {
        return this._flg.isBands;
    }
    get isDestroyed() {
        return this._destroyed;
    }
    get isFullscreen() {
        return this._fsEl && (document.fullscreenElement || document.webkitFullscreenElement) === this._fsEl;
    }
    get isLedBars() {
        return this._flg.isLeds;
    }
    get isLumiBars() {
        return this._flg.isLumi;
    }
    get isOctaveBands() {
        return this._flg.isOctaves;
    }
    get isOn() {
        return !!this._runId;
    }
    get isOutlineBars() {
        return this._flg.isOutline;
    }
    get pixelRatio() {
        return this._pixelRatio;
    }
    get isRoundBars() {
        return this._flg.isRound;
    }
    static get version() {
        return VERSION;
    }
    /**
	 * ==========================================================================
     *
	 * PUBLIC METHODS
	 *
	 * ==========================================================================
	 */ /**
	 * Connects an HTML media element or audio node to the analyzer
	 *
	 * @param {object} an instance of HTMLMediaElement or AudioNode
	 * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise
	 */ connectInput(source) {
        const isHTML = source instanceof HTMLMediaElement;
        if (!(isHTML || source.connect)) throw new AudioMotionError(ERR_INVALID_AUDIO_SOURCE);
        // if source is an HTML element, create an audio node for it; otherwise, use the provided audio node
        const node = isHTML ? this.audioCtx.createMediaElementSource(source) : source;
        if (!this._sources.includes(node)) {
            node.connect(this._input);
            this._sources.push(node);
        }
        return node;
    }
    /**
	 * Connects the analyzer output to another audio node
	 *
	 * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)
	 */ connectOutput(node = this.audioCtx.destination) {
        if (this._outNodes.includes(node)) return;
        this._output.connect(node);
        this._outNodes.push(node);
        // when connecting the first node, also connect the analyzer nodes to the merger / output nodes
        if (this._outNodes.length == 1) {
            for (const i of [
                0,
                1
            ])this._analyzer[i].connect(this._chLayout == CHANNEL_SINGLE && !i ? this._output : this._merger, 0, i);
        }
    }
    /**
	 * Destroys instance
	 */ destroy() {
        if (!this._ready) return;
        const { audioCtx, canvas, _controller, _input, _merger, _observer, _ownCanvas, _ownContext, _splitter } = this;
        this._destroyed = true;
        this._ready = false;
        this.stop();
        // remove event listeners
        _controller.abort();
        if (_observer) _observer.disconnect();
        // clear callbacks and fullscreen element
        this.onCanvasResize = null;
        this.onCanvasDraw = null;
        this._fsEl = null;
        // disconnect audio nodes
        this.disconnectInput();
        this.disconnectOutput(); // also disconnects analyzer nodes
        _input.disconnect();
        _splitter.disconnect();
        _merger.disconnect();
        // if audio context is our own (not provided by the user), close it
        if (_ownContext) audioCtx.close();
        // remove canvas from the DOM (if not provided by the user)
        if (_ownCanvas) canvas.remove();
        // reset flags
        this._calcBars();
    }
    /**
	 * Disconnects audio sources from the analyzer
	 *
	 * @param [{object|array}] a connected AudioNode object or an array of such objects; if falsy, all connected nodes are disconnected
	 * @param [{boolean}] if true, stops/releases audio tracks from disconnected media streams (e.g. microphone)
	 */ disconnectInput(sources, stopTracks) {
        if (!sources) sources = Array.from(this._sources);
        else if (!Array.isArray(sources)) sources = [
            sources
        ];
        for (const node of sources){
            const idx = this._sources.indexOf(node);
            if (stopTracks && node.mediaStream) {
                for (const track of node.mediaStream.getAudioTracks()){
                    track.stop();
                }
            }
            if (idx >= 0) {
                node.disconnect(this._input);
                this._sources.splice(idx, 1);
            }
        }
    }
    /**
	 * Disconnects the analyzer output from other audio nodes
	 *
	 * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected
	 */ disconnectOutput(node) {
        if (node && !this._outNodes.includes(node)) return;
        this._output.disconnect(node);
        this._outNodes = node ? this._outNodes.filter((e)=>e !== node) : [];
        // if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium
        // see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848
        if (this._outNodes.length == 0) {
            for (const i of [
                0,
                1
            ])this._analyzer[i].disconnect();
        }
    }
    /**
	 * Returns analyzer bars data
     *
	 * @returns {array}
	 */ getBars() {
        return Array.from(this._bars, ({ posX, freq, freqLo, freqHi, hold, peak, value })=>({
                posX,
                freq,
                freqLo,
                freqHi,
                hold,
                peak,
                value
            }));
    }
    /**
	 * Returns the energy of a frequency, or average energy of a range of frequencies
	 *
	 * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy
	 * @param [{number}] ending frequency (Hz)
	 * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown
	 */ getEnergy(startFreq, endFreq) {
        if (startFreq === undefined) return this._energy.val;
        // if startFreq is a string, check for presets
        if (startFreq != +startFreq) {
            if (startFreq == 'peak') return this._energy.peak;
            const presets = {
                bass: [
                    20,
                    250
                ],
                lowMid: [
                    250,
                    500
                ],
                mid: [
                    500,
                    2e3
                ],
                highMid: [
                    2e3,
                    4e3
                ],
                treble: [
                    4e3,
                    16e3
                ]
            };
            if (!presets[startFreq]) return null;
            [startFreq, endFreq] = presets[startFreq];
        }
        const startBin = this._freqToBin(startFreq), endBin = endFreq ? this._freqToBin(endFreq) : startBin, chnCount = this._chLayout == CHANNEL_SINGLE ? 1 : 2;
        let energy = 0;
        for(let channel = 0; channel < chnCount; channel++){
            for(let i = startBin; i <= endBin; i++)energy += this._normalizedB(this._fftData[channel][i]);
        }
        return energy / (endBin - startBin + 1) / chnCount;
    }
    /**
	 * Returns current analyzer settings in object format
	 *
	 * @param [{string|array}] a property name or an array of property names to not include in the returned object
	 * @returns {object} Options object
	 */ getOptions(ignore) {
        if (!Array.isArray(ignore)) ignore = [
            ignore
        ];
        let options = {};
        for (const prop of Object.keys(DEFAULT_SETTINGS)){
            if (!ignore.includes(prop)) {
                if (prop == 'gradient' && this.gradientLeft != this.gradientRight) {
                    options.gradientLeft = this.gradientLeft;
                    options.gradientRight = this.gradientRight;
                } else if (prop != 'start') options[prop] = this[prop];
            }
        }
        return options;
    }
    /**
	 * Registers a custom gradient
	 *
	 * @param {string} name
	 * @param {object} options
	 */ registerGradient(name, options) {
        if (typeof name != 'string' || name.trim().length == 0) throw new AudioMotionError(ERR_GRADIENT_INVALID_NAME);
        if (typeof options != 'object') throw new AudioMotionError(ERR_GRADIENT_NOT_AN_OBJECT);
        const { colorStops } = options;
        if (!Array.isArray(colorStops) || !colorStops.length) throw new AudioMotionError(ERR_GRADIENT_MISSING_COLOR);
        const count = colorStops.length, isInvalid = (val)=>+val != val || val < 0 || val > 1;
        // normalize all colorStops as objects with `pos`, `color` and `level` properties
        colorStops.forEach((colorStop, index)=>{
            const pos = index / Math.max(1, count - 1);
            if (typeof colorStop != 'object') colorStops[index] = {
                pos,
                color: colorStop
            };
            else if (isInvalid(colorStop.pos)) colorStop.pos = pos;
            if (isInvalid(colorStop.level)) colorStops[index].level = 1 - index / count;
        });
        // make sure colorStops is in descending `level` order and that the first one has `level == 1`
        // this is crucial for proper operation of 'bar-level' colorMode!
        colorStops.sort((a, b)=>a.level < b.level ? 1 : a.level > b.level ? -1 : 0);
        colorStops[0].level = 1;
        this._gradients[name] = {
            bgColor: options.bgColor || GRADIENT_DEFAULT_BGCOLOR,
            dir: options.dir,
            colorStops: colorStops
        };
        // if the registered gradient is one of the currently selected gradients, regenerate them
        if (this._selectedGrads.includes(name)) this._makeGrad();
    }
    /**
	 * Set dimensions of analyzer's canvas
	 *
	 * @param {number} w width in pixels
	 * @param {number} h height in pixels
	 */ setCanvasSize(w, h) {
        this._width = w;
        this._height = h;
        this._setCanvas(REASON_USER);
    }
    /**
	 * Set desired frequency range
	 *
	 * @param {number} min lowest frequency represented in the x-axis
	 * @param {number} max highest frequency represented in the x-axis
	 */ setFreqRange(min, max) {
        if (min < 1 || max < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW);
        else {
            this._minFreq = Math.min(min, max);
            this.maxFreq = Math.max(min, max); // use the setter for maxFreq
        }
    }
    /**
	 * Set custom parameters for LED effect
	 * If called with no arguments or if any property is invalid, clears any previous custom parameters
	 *
	 * @param {object} [params]
	 */ setLedParams(params) {
        let maxLeds, spaceV, spaceH;
        // coerce parameters to Number; `NaN` results are rejected in the condition below
        if (params) {
            maxLeds = params.maxLeds | 0, spaceV = +params.spaceV, spaceH = +params.spaceH;
        }
        this._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [
            maxLeds,
            spaceV,
            spaceH
        ] : undefined;
        this._calcBars();
    }
    /**
	 * Shorthand function for setting several options at once
	 *
	 * @param {object} options
	 */ setOptions(options) {
        this._setProps(options);
    }
    /**
	 * Adjust the analyzer's sensitivity
	 *
	 * @param {number} min minimum decibels value
	 * @param {number} max maximum decibels value
	 */ setSensitivity(min, max) {
        for (const i of [
            0,
            1
        ]){
            this._analyzer[i].minDecibels = Math.min(min, max);
            this._analyzer[i].maxDecibels = Math.max(min, max);
        }
    }
    /**
	 * Start the analyzer
	 */ start() {
        this.toggleAnalyzer(true);
    }
    /**
	 * Stop the analyzer
	 */ stop() {
        this.toggleAnalyzer(false);
    }
    /**
	 * Start / stop canvas animation
	 *
	 * @param {boolean} [force] if undefined, inverts the current state
	 * @returns {boolean} resulting state after the change
	 */ toggleAnalyzer(force) {
        const hasStarted = this.isOn;
        if (force === undefined) force = !hasStarted;
        // Stop the analyzer if it was already running and must be disabled
        if (hasStarted && !force) {
            cancelAnimationFrame(this._runId);
            this._runId = 0;
        } else if (!hasStarted && force && !this._destroyed) {
            this._frames = 0;
            this._time = performance.now();
            this._runId = requestAnimationFrame((timestamp)=>this._draw(timestamp)); // arrow function preserves the scope of *this*
        }
        return this.isOn;
    }
    /**
	 * Toggles canvas full-screen mode
	 */ toggleFullscreen() {
        if (this.isFullscreen) {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        } else {
            const fsEl = this._fsEl;
            if (!fsEl) return;
            if (fsEl.requestFullscreen) fsEl.requestFullscreen();
            else if (fsEl.webkitRequestFullscreen) fsEl.webkitRequestFullscreen();
        }
    }
    /**
	 * ==========================================================================
	 *
	 * PRIVATE METHODS
	 *
	 * ==========================================================================
	 */ /**
	 * Return the frequency (in Hz) for a given FFT bin
	 */ _binToFreq(bin) {
        return bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0
    }
    /**
	 * Compute all internal data required for the analyzer, based on its current settings
	 */ _calcBars() {
        const bars = this._bars = []; // initialize object property
        if (!this._ready) {
            this._flg = {
                isAlpha: false,
                isBands: false,
                isLeds: false,
                isLumi: false,
                isOctaves: false,
                isOutline: false,
                isRound: false,
                noLedGap: false
            };
            return;
        }
        const { _ansiBands, _barSpace, canvas, _chLayout, _maxFreq, _minFreq, _mirror, _mode, _radial, _radialInvert, _reflexRatio } = this, centerX = canvas.width >> 1, centerY = canvas.height >> 1, isDualVertical = _chLayout == CHANNEL_VERTICAL && !_radial, isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL, // COMPUTE FLAGS
        isBands = _mode % 10 != 0, isOctaves = isBands && this._frequencyScale == SCALE_LOG, isLeds = this._showLeds && isBands && !_radial, isLumi = this._lumiBars && isBands && !_radial, isAlpha = this._alphaBars && !isLumi && _mode != MODE_GRAPH, isOutline = this._outlineBars && isBands && !isLumi && !isLeds, isRound = this._roundBars && isBands && !isLumi && !isLeds, noLedGap = _chLayout != CHANNEL_VERTICAL || _reflexRatio > 0 && !isLumi, // COMPUTE AUXILIARY VALUES
        // channelHeight is the total canvas height dedicated to each channel, including the reflex area, if any)
        channelHeight = canvas.height - (isDualVertical && !isLeds ? .5 : 0) >> isDualVertical, // analyzerHeight is the effective height used to render the analyzer, excluding the reflex area
        analyzerHeight = channelHeight * (isLumi || _radial ? 1 : 1 - _reflexRatio) | 0, analyzerWidth = canvas.width - centerX * (isDualHorizontal || _mirror != 0), // channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even
        // TODO: improve this, make it configurable?
        channelGap = isDualVertical ? canvas.height - channelHeight * 2 : 0, initialX = centerX * (_mirror == -1 && !isDualHorizontal && !_radial);
        let innerRadius = Math.min(canvas.width, canvas.height) * .375 * (_chLayout == CHANNEL_VERTICAL ? 1 : this._radius) | 0, outerRadius = Math.min(centerX, centerY);
        if (_radialInvert && _chLayout != CHANNEL_VERTICAL) [innerRadius, outerRadius] = [
            outerRadius,
            innerRadius
        ];
        /**
		 *	CREATE ANALYZER BANDS
		 *
		 *	USES:
		 *		analyzerWidth
		 *		initialX
		 *		isBands
		 *		isOctaves
		 *
		 *	GENERATES:
		 *		bars (populates this._bars)
		 *		bardWidth
		 *		scaleMin
		 *		unitWidth
		 */ // helper function to add a bar to the bars array
        // bar object format:
        // {
        //	 posX,
        //   freq,
        //   freqLo,
        //   freqHi,
        //   binLo,
        //   binHi,
        //   ratioLo,
        //   ratioHi,
        //   peak,    // peak value
        //   hold,    // peak hold frames (negative value indicates peak falling / fading)
        //   alpha,   // peak alpha (used by fadePeaks)
        //   value    // current bar value
        // }
        const barsPush = (args)=>bars.push({
                ...args,
                peak: [
                    0,
                    0
                ],
                hold: [
                    0
                ],
                alpha: [
                    0
                ],
                value: [
                    0
                ]
            });
        /*
			A simple interpolation is used to obtain an approximate amplitude value for any given frequency,
			from the available FFT data. We find the FFT bin which closer matches the desired frequency	and
			interpolate its value with that of the next adjacent bin, like so:

				v = v0 + ( v1 - v0 ) * ( log2( f / f0 ) / log2( f1 / f0 ) )
				                       \__________________________________/
				                                        |
				                                      ratio
				where:

				f  - desired frequency
				v  - amplitude (volume) of desired frequency
				f0 - frequency represented by the lower FFT bin
				f1 - frequency represented by the upper FFT bin
				v0 - amplitude of f0
				v1 - amplitude of f1

			ratio is calculated in advance here, to reduce computational complexity during real-time rendering.
		*/ // helper function to calculate FFT bin and interpolation ratio for a given frequency
        const calcRatio = (freq)=>{
            const bin = this._freqToBin(freq, 'floor'), lower = this._binToFreq(bin), upper = this._binToFreq(bin + 1), ratio = Math.log2(freq / lower) / Math.log2(upper / lower);
            return [
                bin,
                ratio
            ];
        };
        let barWidth, scaleMin, unitWidth;
        if (isOctaves) {
            // helper function to round a value to a given number of significant digits
            // `atLeast` set to true prevents reducing the number of integer significant digits
            const roundSD = (value, digits, atLeast)=>+value.toPrecision(atLeast ? Math.max(digits, 1 + Math.log10(value) | 0) : digits);
            // helper function to find the nearest preferred number (Renard series) for a given value
            const nearestPreferred = (value)=>{
                // R20 series is used here, as it provides closer approximations for 1/2 octave bands (non-standard)
                const preferred = [
                    1,
                    1.12,
                    1.25,
                    1.4,
                    1.6,
                    1.8,
                    2,
                    2.24,
                    2.5,
                    2.8,
                    3.15,
                    3.55,
                    4,
                    4.5,
                    5,
                    5.6,
                    6.3,
                    7.1,
                    8,
                    9,
                    10
                ], power = Math.log10(value) | 0, normalized = value / 10 ** power;
                let i = 1;
                while(i < preferred.length && normalized > preferred[i])i++;
                if (normalized - preferred[i - 1] < preferred[i] - normalized) i--;
                return (preferred[i] * 10 ** (power + 5) | 0) / 1e5; // keep 5 significant digits
            };
            // ANSI standard octave bands use the base-10 frequency ratio, as preferred by [ANSI S1.11-2004, p.2]
            // The equal-tempered scale uses the base-2 ratio
            const bands = [
                0,
                24,
                12,
                8,
                6,
                4,
                3,
                2,
                1
            ][_mode], bandWidth = _ansiBands ? 10 ** (3 / (bands * 10)) : 2 ** (1 / bands), halfBand = bandWidth ** .5;
            let analyzerBars = [], currFreq = _ansiBands ? 7.94328235 / (bands % 2 ? 1 : halfBand) : C_1;
            // For ANSI bands with even denominators (all except 1/1 and 1/3), the reference frequency (1 kHz)
            // must fall on the edges of a pair of adjacent bands, instead of midband [ANSI S1.11-2004, p.2]
            // In the equal-tempered scale, all midband frequencies represent a musical note or quarter-tone.
            do {
                let freq = currFreq; // midband frequency
                const freqLo = roundSD(freq / halfBand, 4, true), freqHi = roundSD(freq * halfBand, 4, true), [binLo, ratioLo] = calcRatio(freqLo), [binHi, ratioHi] = calcRatio(freqHi);
                // for 1/1, 1/2 and 1/3 ANSI bands, use the preferred numbers to find the nominal midband frequency
                // for 1/4 to 1/24, round to 2 or 3 significant digits, according to the MSD [ANSI S1.11-2004, p.12]
                if (_ansiBands) freq = bands < 4 ? nearestPreferred(freq) : roundSD(freq, freq.toString()[0] < 5 ? 3 : 2);
                else freq = roundSD(freq, 4, true);
                if (freq >= _minFreq) barsPush({
                    posX: 0,
                    freq,
                    freqLo,
                    freqHi,
                    binLo,
                    binHi,
                    ratioLo,
                    ratioHi
                });
                currFreq *= bandWidth;
            }while (currFreq <= _maxFreq)
            barWidth = analyzerWidth / bars.length;
            bars.forEach((bar, index)=>bar.posX = initialX + index * barWidth);
            const firstBar = bars[0], lastBar = bars[bars.length - 1];
            scaleMin = this._freqScaling(firstBar.freqLo);
            unitWidth = analyzerWidth / (this._freqScaling(lastBar.freqHi) - scaleMin);
            // clamp edge frequencies to minFreq / maxFreq, if necessary
            // this is done after computing scaleMin and unitWidth, for the proper positioning of labels on the X-axis
            if (firstBar.freqLo < _minFreq) {
                firstBar.freqLo = _minFreq;
                [firstBar.binLo, firstBar.ratioLo] = calcRatio(_minFreq);
            }
            if (lastBar.freqHi > _maxFreq) {
                lastBar.freqHi = _maxFreq;
                [lastBar.binHi, lastBar.ratioHi] = calcRatio(_maxFreq);
            }
        } else if (isBands) {
            const bands = [
                0,
                24,
                12,
                8,
                6,
                4,
                3,
                2,
                1
            ][_mode] * 10;
            const invFreqScaling = (x)=>{
                switch(this._frequencyScale){
                    case SCALE_BARK:
                        return 1960 / (26.81 / (x + .53) - 1);
                    case SCALE_MEL:
                        return 700 * (2 ** x - 1);
                    case SCALE_LINEAR:
                        return x;
                }
            };
            barWidth = analyzerWidth / bands;
            scaleMin = this._freqScaling(_minFreq);
            unitWidth = analyzerWidth / (this._freqScaling(_maxFreq) - scaleMin);
            for(let i = 0, posX = 0; i < bands; i++, posX += barWidth){
                const freqLo = invFreqScaling(scaleMin + posX / unitWidth), freq = invFreqScaling(scaleMin + (posX + barWidth / 2) / unitWidth), freqHi = invFreqScaling(scaleMin + (posX + barWidth) / unitWidth), [binLo, ratioLo] = calcRatio(freqLo), [binHi, ratioHi] = calcRatio(freqHi);
                barsPush({
                    posX: initialX + posX,
                    freq,
                    freqLo,
                    freqHi,
                    binLo,
                    binHi,
                    ratioLo,
                    ratioHi
                });
            }
        } else {
            barWidth = 1;
            scaleMin = this._freqScaling(_minFreq);
            unitWidth = analyzerWidth / (this._freqScaling(_maxFreq) - scaleMin);
            const minIndex = this._freqToBin(_minFreq, 'floor'), maxIndex = this._freqToBin(_maxFreq);
            let lastPos = -999;
            for(let i = minIndex; i <= maxIndex; i++){
                const freq = this._binToFreq(i), posX = initialX + Math.round(unitWidth * (this._freqScaling(freq) - scaleMin)); // avoid fractionary pixel values
                // if it's on a different X-coordinate, create a new bar for this frequency
                if (posX > lastPos) {
                    barsPush({
                        posX,
                        freq,
                        freqLo: freq,
                        freqHi: freq,
                        binLo: i,
                        binHi: i,
                        ratioLo: 0,
                        ratioHi: 0
                    });
                    lastPos = posX;
                } else if (bars.length) {
                    const lastBar = bars[bars.length - 1];
                    lastBar.binHi = i;
                    lastBar.freqHi = freq;
                    lastBar.freq = (lastBar.freqLo * freq) ** .5; // compute center frequency (geometric mean)
                }
            }
        }
        /**
		 *  COMPUTE ATTRIBUTES FOR THE LED BARS
		 *
		 *	USES:
		 *		analyzerHeight
		 *		barWidth
		 *		noLedGap
		 *
		 *	GENERATES:
		 * 		spaceH
		 * 		spaceV
		 *		this._leds
		 */ let spaceH = 0, spaceV = 0;
        if (isLeds) {
            // adjustment for high pixel-ratio values on low-resolution screens (Android TV)
            const dPR = this._pixelRatio / (window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1);
            const params = [
                [],
                [
                    128,
                    3,
                    .45
                ],
                [
                    128,
                    4,
                    .225
                ],
                [
                    96,
                    6,
                    .225
                ],
                [
                    80,
                    6,
                    .225
                ],
                [
                    80,
                    6,
                    .125
                ],
                [
                    64,
                    6,
                    .125
                ],
                [
                    48,
                    8,
                    .125
                ],
                [
                    24,
                    16,
                    .125
                ]
            ];
            // use custom LED parameters if set, or the default parameters for the current mode
            const customParams = this._ledParams, [maxLeds, spaceVRatio, spaceHRatio] = customParams || params[_mode];
            let ledCount, maxHeight = analyzerHeight;
            if (customParams) {
                const minHeight = 2 * dPR;
                let blockHeight;
                ledCount = maxLeds + 1;
                do {
                    ledCount--;
                    blockHeight = maxHeight / ledCount / (1 + spaceVRatio);
                    spaceV = blockHeight * spaceVRatio;
                }while ((blockHeight < minHeight || spaceV < minHeight) && ledCount > 1)
            } else {
                // calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px
                const refRatio = 540 / spaceVRatio;
                spaceV = Math.min(spaceVRatio * dPR, Math.max(2, maxHeight / refRatio + .1 | 0));
            }
            // remove the extra spacing below the last line of LEDs
            if (noLedGap) maxHeight += spaceV;
            // recalculate the number of leds, considering the effective spaceV
            if (!customParams) ledCount = Math.min(maxLeds, maxHeight / (spaceV * 2) | 0);
            spaceH = spaceHRatio >= 1 ? spaceHRatio : barWidth * spaceHRatio;
            this._leds = [
                ledCount,
                spaceH,
                spaceV,
                maxHeight / ledCount - spaceV // ledHeight
            ];
        }
        // COMPUTE ADDITIONAL BAR POSITIONING, ACCORDING TO THE CURRENT SETTINGS
        // uses: _barSpace, barWidth, spaceH
        const barSpacePx = Math.min(barWidth - 1, _barSpace * (_barSpace > 0 && _barSpace < 1 ? barWidth : 1));
        if (isBands) barWidth -= Math.max(isLeds ? spaceH : 0, barSpacePx);
        bars.forEach((bar, index)=>{
            let posX = bar.posX, width = barWidth;
            // in bands modes we need to update bar.posX to account for bar/led spacing
            if (isBands) {
                if (_barSpace == 0 && !isLeds) {
                    // when barSpace == 0 use integer values for perfect gapless positioning
                    posX |= 0;
                    width |= 0;
                    if (index > 0 && posX > bars[index - 1].posX + bars[index - 1].width) {
                        posX--;
                        width++;
                    }
                } else posX += Math.max(isLeds ? spaceH : 0, barSpacePx) / 2;
                bar.posX = posX; // update
            }
            bar.barCenter = posX + (barWidth == 1 ? 0 : width / 2);
            bar.width = width;
        });
        // COMPUTE CHANNEL COORDINATES (uses spaceV)
        const channelCoords = [];
        for (const channel of [
            0,
            1
        ]){
            const channelTop = _chLayout == CHANNEL_VERTICAL ? (channelHeight + channelGap) * channel : 0, channelBottom = channelTop + channelHeight, analyzerBottom = channelTop + analyzerHeight - (!isLeds || noLedGap ? 0 : spaceV);
            channelCoords.push({
                channelTop,
                channelBottom,
                analyzerBottom
            });
        }
        // SAVE INTERNAL PROPERTIES
        this._aux = {
            analyzerHeight,
            analyzerWidth,
            centerX,
            centerY,
            channelCoords,
            channelHeight,
            channelGap,
            initialX,
            innerRadius,
            outerRadius,
            scaleMin,
            unitWidth
        };
        this._flg = {
            isAlpha,
            isBands,
            isLeds,
            isLumi,
            isOctaves,
            isOutline,
            isRound,
            noLedGap
        };
        // generate the X-axis and radial scales
        this._createScales();
    }
    /**
	 * Generate the X-axis and radial scales in auxiliary canvases
	 */ _createScales() {
        if (!this._ready) return;
        const { analyzerWidth, initialX, innerRadius, scaleMin, unitWidth } = this._aux, { canvas, _frequencyScale, _mirror, _noteLabels, _radial, _scaleX, _scaleR } = this, canvasX = _scaleX.canvas, canvasR = _scaleR.canvas, freqLabels = [], isDualHorizontal = this._chLayout == CHANNEL_HORIZONTAL, isDualVertical = this._chLayout == CHANNEL_VERTICAL, minDimension = Math.min(canvas.width, canvas.height), scale = [
            'C',
            ,
            'D',
            ,
            'E',
            'F',
            ,
            'G',
            ,
            'A',
            ,
            'B'
        ], scaleHeight = minDimension / 34 | 0, fontSizeX = canvasX.height >> 1, fontSizeR = scaleHeight >> 1, labelWidthX = fontSizeX * (_noteLabels ? .7 : 1.5), labelWidthR = fontSizeR * (_noteLabels ? 1 : 2), root12 = 2 ** (1 / 12);
        if (!_noteLabels && (this._ansiBands || _frequencyScale != SCALE_LOG)) {
            freqLabels.push(16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3);
            if (_frequencyScale == SCALE_LINEAR) freqLabels.push(6e3, 8e3, 10e3, 12e3, 14e3, 16e3, 18e3, 20e3, 22e3);
            else freqLabels.push(8e3, 16e3);
        } else {
            let freq = C_1;
            for(let octave = -1; octave < 11; octave++){
                for(let note = 0; note < 12; note++){
                    if (freq >= this._minFreq && freq <= this._maxFreq) {
                        const pitch = scale[note], isC = pitch == 'C';
                        if (pitch && _noteLabels && !_mirror && !isDualHorizontal || isC) freqLabels.push(_noteLabels ? [
                            freq,
                            pitch + (isC ? octave : '')
                        ] : freq);
                    }
                    freq *= root12;
                }
            }
        }
        // in radial dual-vertical layout, the scale is positioned exactly between both channels, by making the canvas a bit larger than the inner diameter
        canvasR.width = canvasR.height = Math.max(minDimension * .15, (innerRadius << 1) + isDualVertical * scaleHeight);
        const centerR = canvasR.width >> 1, radialY = centerR - scaleHeight * .7; // vertical position of text labels in the circular scale
        // helper function
        const radialLabel = (x, label)=>{
            const angle = TAU * (x / canvas.width), adjAng = angle - HALF_PI, posX = radialY * Math.cos(adjAng), posY = radialY * Math.sin(adjAng);
            _scaleR.save();
            _scaleR.translate(centerR + posX, centerR + posY);
            _scaleR.rotate(angle);
            _scaleR.fillText(label, 0, 0);
            _scaleR.restore();
        };
        // clear scale canvas
        canvasX.width |= 0;
        _scaleX.fillStyle = _scaleR.strokeStyle = SCALEX_BACKGROUND_COLOR;
        _scaleX.fillRect(0, 0, canvasX.width, canvasX.height);
        _scaleR.arc(centerR, centerR, centerR - scaleHeight / 2, 0, TAU);
        _scaleR.lineWidth = scaleHeight;
        _scaleR.stroke();
        _scaleX.fillStyle = _scaleR.fillStyle = SCALEX_LABEL_COLOR;
        _scaleX.font = `${fontSizeX}px ${FONT_FAMILY}`;
        _scaleR.font = `${fontSizeR}px ${FONT_FAMILY}`;
        _scaleX.textAlign = _scaleR.textAlign = 'center';
        let prevX = -labelWidthX / 4, prevR = -labelWidthR;
        for (const item of freqLabels){
            const [freq, label] = Array.isArray(item) ? item : [
                item,
                item < 1e3 ? item | 0 : `${(item / 100 | 0) / 10}k`
            ], x = unitWidth * (this._freqScaling(freq) - scaleMin), y = canvasX.height * .75, isC = label[0] == 'C', maxW = fontSizeX * (_noteLabels && !_mirror && !isDualHorizontal ? isC ? 1.2 : .6 : 3);
            // set label color - no highlight when mirror effect is active (only Cs displayed)
            _scaleX.fillStyle = _scaleR.fillStyle = isC && !_mirror && !isDualHorizontal ? SCALEX_HIGHLIGHT_COLOR : SCALEX_LABEL_COLOR;
            // prioritizes which note labels are displayed, due to the restricted space on some ranges/scales
            if (_noteLabels) {
                const isLog = _frequencyScale == SCALE_LOG, isLinear = _frequencyScale == SCALE_LINEAR;
                let allowedLabels = [
                    'C'
                ];
                if (isLog || freq > 2e3 || !isLinear && freq > 250 || (!_radial || isDualVertical) && (!isLinear && freq > 125 || freq > 1e3)) allowedLabels.push('G');
                if (isLog || freq > 4e3 || !isLinear && freq > 500 || (!_radial || isDualVertical) && (!isLinear && freq > 250 || freq > 2e3)) allowedLabels.push('E');
                if (isLinear && freq > 4e3 || (!_radial || isDualVertical) && (isLog || freq > 2e3 || !isLinear && freq > 500)) allowedLabels.push('D', 'F', 'A', 'B');
                if (!allowedLabels.includes(label[0])) continue; // skip this label
            }
            // linear scale
            if (x >= prevX + labelWidthX / 2 && x <= analyzerWidth) {
                _scaleX.fillText(label, isDualHorizontal && _mirror == -1 ? analyzerWidth - x : initialX + x, y, maxW);
                if (isDualHorizontal || _mirror && (x > labelWidthX || _mirror == 1)) _scaleX.fillText(label, isDualHorizontal && _mirror != 1 ? analyzerWidth + x : (initialX || canvas.width) - x, y, maxW);
                prevX = x + Math.min(maxW, _scaleX.measureText(label).width) / 2;
            }
            // radial scale
            if (x >= prevR + labelWidthR && x < analyzerWidth - labelWidthR) {
                radialLabel(isDualHorizontal && _mirror == 1 ? analyzerWidth - x : x, label);
                if (isDualHorizontal || _mirror && (x > labelWidthR || _mirror == 1)) radialLabel(isDualHorizontal && _mirror != -1 ? analyzerWidth + x : -x, label);
                prevR = x;
            }
        }
    }
    /**
	 * Redraw the canvas
	 * this is called 60 times per second by requestAnimationFrame()
	 */ _draw(timestamp) {
        // schedule next canvas update
        this._runId = requestAnimationFrame((timestamp)=>this._draw(timestamp));
        // frame rate control
        const elapsed = timestamp - this._time, frameTime = timestamp - this._last, targetInterval = this._maxFPS ? 975 / this._maxFPS : 0; // small tolerance for best results
        if (frameTime < targetInterval) return;
        this._last = timestamp - (targetInterval ? frameTime % targetInterval : 0); // thanks https://stackoverflow.com/a/19772220/2370385
        this._frames++;
        if (elapsed >= 1000) {
            this._fps = this._frames / elapsed * 1000;
            this._frames = 0;
            this._time = timestamp;
        }
        // initialize local constants
        const { isAlpha, isBands, isLeds, isLumi, isOctaves, isOutline, isRound, noLedGap } = this._flg, { analyzerHeight, centerX, centerY, channelCoords, channelHeight, channelGap, initialX, innerRadius, outerRadius } = this._aux, { _bars, canvas, _canvasGradients, _chLayout, _colorMode, _ctx, _energy, _fadePeaks, fillAlpha, _fps, _linearAmplitude, _lineWidth, maxDecibels, minDecibels, _mirror, _mode, overlay, _radial, showBgColor, showPeaks, useCanvas, _weightingFilter } = this, canvasX = this._scaleX.canvas, canvasR = this._scaleR.canvas, fadeFrames = _fps * this._peakFadeTime / 1e3, fpsSquared = _fps ** 2, gravity = this._gravity * 1e3, holdFrames = _fps * this._peakHoldTime / 1e3, isDualCombined = _chLayout == CHANNEL_COMBINED, isDualHorizontal = _chLayout == CHANNEL_HORIZONTAL, isDualVertical = _chLayout == CHANNEL_VERTICAL, isSingle = _chLayout == CHANNEL_SINGLE, isTrueLeds = isLeds && this._trueLeds && _colorMode == COLOR_GRADIENT, analyzerWidth = _radial ? canvas.width : this._aux.analyzerWidth, finalX = initialX + analyzerWidth, showPeakLine = showPeaks && this._peakLine && _mode == MODE_GRAPH, maxBarHeight = _radial ? outerRadius - innerRadius : analyzerHeight, nominalMaxHeight = maxBarHeight / this._pixelRatio, dbRange = maxDecibels - minDecibels, [ledCount, ledSpaceH, ledSpaceV, ledHeight] = this._leds || [];
        if (_energy.val > 0 && _fps > 0) this._spinAngle += this._spinSpeed * TAU / 60 / _fps; // spinSpeed * angle increment per frame for 1 RPM
        /* HELPER FUNCTIONS */ // create Reflex effect
        const doReflex = (channel)=>{
            if (this._reflexRatio > 0 && !isLumi && !_radial) {
                let posY, height;
                if (this.reflexFit || isDualVertical) {
                    posY = isDualVertical && channel == 0 ? channelHeight + channelGap : 0;
                    height = channelHeight - analyzerHeight;
                } else {
                    posY = canvas.height - analyzerHeight * 2;
                    height = analyzerHeight;
                }
                _ctx.save();
                // set alpha and brightness for the reflection
                _ctx.globalAlpha = this.reflexAlpha;
                if (this.reflexBright != 1) _ctx.filter = `brightness(${this.reflexBright})`;
                // create the reflection
                _ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
                _ctx.drawImage(canvas, 0, channelCoords[channel].channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height);
                _ctx.restore();
            }
        };
        // draw scale on X-axis
        const drawScaleX = ()=>{
            if (this.showScaleX) {
                if (_radial) {
                    _ctx.save();
                    _ctx.translate(centerX, centerY);
                    if (this._spinSpeed) _ctx.rotate(this._spinAngle + HALF_PI);
                    _ctx.drawImage(canvasR, -canvasR.width >> 1, -canvasR.width >> 1);
                    _ctx.restore();
                } else _ctx.drawImage(canvasX, 0, canvas.height - canvasX.height);
            }
        };
        // returns the gain (in dB) for a given frequency, considering the currently selected weighting filter
        const weightingdB = (freq)=>{
            const f2 = freq ** 2, SQ20_6 = 424.36, SQ107_7 = 11599.29, SQ158_5 = 25122.25, SQ737_9 = 544496.41, SQ12194 = 148693636, linearTodB = (value)=>20 * Math.log10(value);
            switch(_weightingFilter){
                case FILTER_A:
                    const rA = SQ12194 * f2 ** 2 / ((f2 + SQ20_6) * Math.sqrt((f2 + SQ107_7) * (f2 + SQ737_9)) * (f2 + SQ12194));
                    return 2 + linearTodB(rA);
                case FILTER_B:
                    const rB = SQ12194 * f2 * freq / ((f2 + SQ20_6) * Math.sqrt(f2 + SQ158_5) * (f2 + SQ12194));
                    return .17 + linearTodB(rB);
                case FILTER_C:
                    const rC = SQ12194 * f2 / ((f2 + SQ20_6) * (f2 + SQ12194));
                    return .06 + linearTodB(rC);
                case FILTER_D:
                    const h = ((1037918.48 - f2) ** 2 + 1080768.16 * f2) / ((9837328 - f2) ** 2 + 11723776 * f2), rD = freq / 6.8966888496476e-5 * Math.sqrt(h / ((f2 + 79919.29) * (f2 + 1345600)));
                    return linearTodB(rD);
                case FILTER_468:
                    const h1 = -4.737338981378384e-24 * freq ** 6 + 2.043828333606125e-15 * freq ** 4 - 1.363894795463638e-7 * f2 + 1, h2 = 1.306612257412824e-19 * freq ** 5 - 2.118150887518656e-11 * freq ** 3 + 5.559488023498642e-4 * freq, rI = 1.246332637532143e-4 * freq / Math.hypot(h1, h2);
                    return 18.2 + linearTodB(rI);
            }
            return 0; // unknown filter
        };
        // draws (stroke) a bar from x,y1 to x,y2
        const strokeBar = (x, y1, y2)=>{
            _ctx.beginPath();
            _ctx.moveTo(x, y1);
            _ctx.lineTo(x, y2);
            _ctx.stroke();
        };
        // conditionally strokes current path on canvas
        const strokeIf = (flag)=>{
            if (flag && _lineWidth) {
                const alpha = _ctx.globalAlpha;
                _ctx.globalAlpha = 1;
                _ctx.stroke();
                _ctx.globalAlpha = alpha;
            }
        };
        // converts a value in [0;1] range to a height in pixels that fits into the current LED elements
        const ledPosY = (value)=>Math.max(0, (value * ledCount | 0) * (ledHeight + ledSpaceV) - ledSpaceV);
        // update energy information
        const updateEnergy = (newVal)=>{
            _energy.val = newVal;
            if (_energy.peak > 0) {
                _energy.hold--;
                if (_energy.hold < 0) _energy.peak += _energy.hold * gravity / fpsSquared / canvas.height * this._pixelRatio;
            // TO-DO: replace `canvas.height * this._pixelRatio` with `maxNominalHeight` when implementing dual-channel energy
            }
            if (newVal >= _energy.peak) {
                _energy.peak = newVal;
                _energy.hold = holdFrames;
            }
        };
        /* MAIN FUNCTION */ if (overlay) _ctx.clearRect(0, 0, canvas.width, canvas.height);
        let currentEnergy = 0;
        const nBars = _bars.length, nChannels = isSingle ? 1 : 2;
        for(let channel = 0; channel < nChannels; channel++){
            const { channelTop, channelBottom, analyzerBottom } = channelCoords[channel], channelGradient = this._gradients[this._selectedGrads[channel]], colorStops = channelGradient.colorStops, colorCount = colorStops.length, bgColor = !showBgColor || isLeds && !overlay ? '#000' : channelGradient.bgColor, radialDirection = isDualVertical && _radial && channel ? -1 : 1, invertedChannel = !channel && _mirror == -1 || channel && _mirror == 1, radialOffsetX = !isDualHorizontal || channel && _mirror != 1 ? 0 : analyzerWidth >> (channel || !invertedChannel), angularDirection = isDualHorizontal && invertedChannel ? -1 : 1; // 1 = clockwise, -1 = counterclockwise
            /*
			Expanded logic for radialOffsetX and angularDirection:

			let radialOffsetX = 0,
				angularDirection = 1;

			if ( isDualHorizontal ) {
				if ( channel == 0 ) { // LEFT channel
					if ( _mirror == -1 ) {
						radialOffsetX = analyzerWidth;
						angularDirection = -1;
					}
					else
						radialOffsetX = analyzerWidth >> 1;
				}
				else {                // RIGHT channel
					if ( _mirror == 1 ) {
						radialOffsetX = analyzerWidth >> 1;
						angularDirection = -1;
					}
				}
			}
*/ // draw scale on Y-axis (uses: channel, channelTop)
            const drawScaleY = ()=>{
                const scaleWidth = canvasX.height, fontSize = scaleWidth >> 1, max = _linearAmplitude ? 100 : maxDecibels, min = _linearAmplitude ? 0 : minDecibels, incr = _linearAmplitude ? 20 : 5, interval = analyzerHeight / (max - min), atStart = _mirror != -1 && (!isDualHorizontal || channel == 0 || _mirror == 1), atEnd = _mirror != 1 && (!isDualHorizontal || channel != _mirror);
                _ctx.save();
                _ctx.fillStyle = SCALEY_LABEL_COLOR;
                _ctx.font = `${fontSize}px ${FONT_FAMILY}`;
                _ctx.textAlign = 'right';
                _ctx.lineWidth = 1;
                for(let val = max; val > min; val -= incr){
                    const posY = channelTop + (max - val) * interval, even = val % 2 == 0 | 0;
                    if (even) {
                        const labelY = posY + fontSize * (posY == channelTop ? .8 : .35);
                        if (atStart) _ctx.fillText(val, scaleWidth * .85, labelY);
                        if (atEnd) _ctx.fillText(val, (isDualHorizontal ? analyzerWidth : canvas.width) - scaleWidth * .1, labelY);
                        _ctx.strokeStyle = SCALEY_LABEL_COLOR;
                        _ctx.setLineDash([
                            2,
                            4
                        ]);
                        _ctx.lineDashOffset = 0;
                    } else {
                        _ctx.strokeStyle = SCALEY_MIDLINE_COLOR;
                        _ctx.setLineDash([
                            2,
                            8
                        ]);
                        _ctx.lineDashOffset = 1;
                    }
                    _ctx.beginPath();
                    _ctx.moveTo(initialX + scaleWidth * even * atStart, ~~posY + .5); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)
                    _ctx.lineTo(finalX - scaleWidth * even * atEnd, ~~posY + .5);
                    _ctx.stroke();
                }
                _ctx.restore();
            };
            // FFT bin data interpolation (uses fftData)
            const interpolate = (bin, ratio)=>{
                const value = fftData[bin] + (bin < fftData.length - 1 ? (fftData[bin + 1] - fftData[bin]) * ratio : 0);
                return isNaN(value) ? -Infinity : value;
            };
            // converts a given X-coordinate to its corresponding angle in radial mode (uses angularDirection)
            const getAngle = (x, dir = angularDirection)=>dir * TAU * ((x + radialOffsetX) / canvas.width) + this._spinAngle;
            // converts planar X,Y coordinates to radial coordinates (uses: getAngle(), radialDirection)
            const radialXY = (x, y, dir)=>{
                const height = innerRadius + y * radialDirection, angle = getAngle(x, dir);
                return [
                    centerX + height * Math.cos(angle),
                    centerY + height * Math.sin(angle)
                ];
            };
            // draws a polygon of width `w` and height `h` at (x,y) in radial mode (uses: angularDirection, radialDirection)
            const radialPoly = (x, y, w, h, stroke)=>{
                _ctx.beginPath();
                for (const dir of _mirror && !isDualHorizontal ? [
                    1,
                    -1
                ] : [
                    angularDirection
                ]){
                    const [startAngle, endAngle] = isRound ? [
                        getAngle(x, dir),
                        getAngle(x + w, dir)
                    ] : [];
                    _ctx.moveTo(...radialXY(x, y, dir));
                    _ctx.lineTo(...radialXY(x, y + h, dir));
                    if (isRound) _ctx.arc(centerX, centerY, innerRadius + (y + h) * radialDirection, startAngle, endAngle, dir != 1);
                    else _ctx.lineTo(...radialXY(x + w, y + h, dir));
                    _ctx.lineTo(...radialXY(x + w, y, dir));
                    if (isRound && !stroke) _ctx.arc(centerX, centerY, innerRadius + y * radialDirection, endAngle, startAngle, dir == 1);
                }
                strokeIf(stroke);
                _ctx.fill();
            };
            // set fillStyle and strokeStyle according to current colorMode (uses: channel, colorStops, colorCount)
            const setBarColor = (value = 0, barIndex = 0)=>{
                let color;
                // for graph mode, always use the channel gradient (ignore colorMode)
                if (_colorMode == COLOR_GRADIENT && !isTrueLeds || _mode == MODE_GRAPH) color = _canvasGradients[channel];
                else {
                    const selectedIndex = _colorMode == COLOR_BAR_INDEX ? barIndex % colorCount : colorStops.findLastIndex((item)=>isLeds ? ledPosY(value) <= ledPosY(item.level) : value <= item.level);
                    color = colorStops[selectedIndex].color;
                }
                _ctx.fillStyle = _ctx.strokeStyle = color;
            };
            // CHANNEL START
            if (useCanvas) {
                // set transform (horizontal flip and translation) for dual-horizontal layout
                if (isDualHorizontal && !_radial) {
                    const translateX = analyzerWidth * (channel + invertedChannel), flipX = invertedChannel ? -1 : 1;
                    _ctx.setTransform(flipX, 0, 0, 1, translateX, 0);
                }
                // fill the analyzer background if needed (not overlay or overlay + showBgColor)
                if (!overlay || showBgColor) {
                    if (overlay) _ctx.globalAlpha = this.bgAlpha;
                    _ctx.fillStyle = bgColor;
                    // exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)
                    if (channel == 0 || !_radial && !isDualCombined) _ctx.fillRect(initialX, channelTop - channelGap, analyzerWidth, (overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight) + channelGap);
                    _ctx.globalAlpha = 1;
                }
                // draw dB scale (Y-axis) - avoid drawing it twice on 'dual-combined' channel layout
                if (this.showScaleY && !isLumi && !_radial && (channel == 0 || !isDualCombined)) drawScaleY();
                // set line width and dash for LEDs effect
                if (isLeds) {
                    _ctx.setLineDash([
                        ledHeight,
                        ledSpaceV
                    ]);
                    _ctx.lineWidth = _bars[0].width;
                } else _ctx.lineWidth = isOutline ? Math.min(_lineWidth, _bars[0].width / 2) : _lineWidth;
                // set clipping region
                _ctx.save();
                if (!_radial) {
                    const region = new Path2D();
                    region.rect(0, channelTop, canvas.width, analyzerHeight);
                    _ctx.clip(region);
                }
            } // if ( useCanvas )
            // get a new array of data from the FFT
            let fftData = this._fftData[channel];
            this._analyzer[channel].getFloatFrequencyData(fftData);
            // apply weighting
            if (_weightingFilter) fftData = fftData.map((val, idx)=>val + weightingdB(this._binToFreq(idx)));
            // start drawing path (for graph mode)
            _ctx.beginPath();
            // store line graph points to create mirror effect in radial mode
            let points = [];
            // draw bars / lines
            for(let barIndex = 0; barIndex < nBars; barIndex++){
                const bar = _bars[barIndex], { posX, barCenter, width, freq, binLo, binHi, ratioLo, ratioHi } = bar;
                let barValue = Math.max(interpolate(binLo, ratioLo), interpolate(binHi, ratioHi));
                // check additional bins (if any) for this bar and keep the highest value
                for(let j = binLo + 1; j < binHi; j++){
                    if (fftData[j] > barValue) barValue = fftData[j];
                }
                // normalize bar amplitude in [0;1] range
                barValue = this._normalizedB(barValue);
                bar.value[channel] = barValue;
                currentEnergy += barValue;
                // update bar peak
                if (bar.peak[channel] > 0 && bar.alpha[channel] > 0) {
                    bar.hold[channel]--;
                    // if hold is negative, start peak drop or fade out
                    if (bar.hold[channel] < 0) {
                        if (_fadePeaks && !showPeakLine) {
                            const initialAlpha = !isAlpha || isOutline && _lineWidth > 0 ? 1 : isAlpha ? bar.peak[channel] : fillAlpha;
                            bar.alpha[channel] = initialAlpha * (1 + bar.hold[channel] / fadeFrames); // hold is negative, so this is <= 1
                        } else bar.peak[channel] += bar.hold[channel] * gravity / fpsSquared / nominalMaxHeight;
                        // make sure the peak value is reset when using fadePeaks
                        if (bar.alpha[channel] <= 0) bar.peak[channel] = 0;
                    }
                }
                // check if it's a new peak for this bar
                if (barValue >= bar.peak[channel]) {
                    bar.peak[channel] = barValue;
                    bar.hold[channel] = holdFrames;
                    // check whether isAlpha or isOutline are active to start the peak alpha with the proper value
                    bar.alpha[channel] = !isAlpha || isOutline && _lineWidth > 0 ? 1 : isAlpha ? barValue : fillAlpha;
                }
                // if not using the canvas, move earlier to the next bar
                if (!useCanvas) continue;
                // set opacity for bar effects
                _ctx.globalAlpha = isLumi || isAlpha ? barValue : isOutline ? fillAlpha : 1;
                // set fillStyle and strokeStyle for the current bar
                setBarColor(barValue, barIndex);
                // compute actual bar height on screen
                const barHeight = isLumi ? maxBarHeight : isLeds ? ledPosY(barValue) : barValue * maxBarHeight | 0;
                // Draw current bar or line segment
                if (_mode == MODE_GRAPH) {
                    // compute the average between the initial bar (barIndex==0) and the next one
                    // used to smooth the curve when the initial posX is off the screen, in mirror and radial modes
                    const nextBarAvg = barIndex ? 0 : (this._normalizedB(fftData[_bars[1].binLo]) * maxBarHeight + barHeight) / 2;
                    if (_radial) {
                        if (barIndex == 0) {
                            if (isDualHorizontal) _ctx.moveTo(...radialXY(0, 0));
                            _ctx.lineTo(...radialXY(0, posX < 0 ? nextBarAvg : barHeight));
                        }
                        // draw line to the current point, avoiding overlapping wrap-around frequencies
                        if (posX >= 0) {
                            const point = [
                                posX,
                                barHeight
                            ];
                            _ctx.lineTo(...radialXY(...point));
                            points.push(point);
                        }
                    } else {
                        if (barIndex == 0) {
                            // start the line off-screen using the previous FFT bin value as the initial amplitude
                            if (_mirror == -1 && !isDualHorizontal) _ctx.moveTo(initialX, analyzerBottom - (posX < initialX ? nextBarAvg : barHeight));
                            else {
                                const prevFFTData = binLo ? this._normalizedB(fftData[binLo - 1]) * maxBarHeight : barHeight; // use previous FFT bin value, when available
                                _ctx.moveTo(initialX - _lineWidth, analyzerBottom - prevFFTData);
                            }
                        }
                        // draw line to the current point
                        // avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy
                        if (isDualHorizontal || _mirror != -1 || posX >= initialX) _ctx.lineTo(posX, analyzerBottom - barHeight);
                    }
                } else {
                    if (isLeds) {
                        // draw "unlit" leds - avoid drawing it twice on 'dual-combined' channel layout
                        if (showBgColor && !overlay && (channel == 0 || !isDualCombined)) {
                            const alpha = _ctx.globalAlpha;
                            _ctx.strokeStyle = LEDS_UNLIT_COLOR;
                            _ctx.globalAlpha = 1;
                            strokeBar(barCenter, channelTop, analyzerBottom);
                            // restore properties
                            _ctx.strokeStyle = _ctx.fillStyle;
                            _ctx.globalAlpha = alpha;
                        }
                        if (isTrueLeds) {
                            // ledPosY() is used below to fit one entire led height into the selected range
                            const colorIndex = isLumi ? 0 : colorStops.findLastIndex((item)=>ledPosY(barValue) <= ledPosY(item.level));
                            let last = analyzerBottom;
                            for(let i = colorCount - 1; i >= colorIndex; i--){
                                _ctx.strokeStyle = colorStops[i].color;
                                let y = analyzerBottom - (i == colorIndex ? barHeight : ledPosY(colorStops[i].level));
                                strokeBar(barCenter, last, y);
                                last = y - ledSpaceV;
                            }
                        } else strokeBar(barCenter, analyzerBottom, analyzerBottom - barHeight);
                    } else if (posX >= initialX) {
                        if (_radial) radialPoly(posX, 0, width, barHeight, isOutline);
                        else if (isRound) {
                            const halfWidth = width / 2, y = analyzerBottom + halfWidth; // round caps have an additional height of half bar width
                            _ctx.beginPath();
                            _ctx.moveTo(posX, y);
                            _ctx.lineTo(posX, y - barHeight);
                            _ctx.arc(barCenter, y - barHeight, halfWidth, PI, TAU);
                            _ctx.lineTo(posX + width, y);
                            strokeIf(isOutline);
                            _ctx.fill();
                        } else {
                            const offset = isOutline ? _ctx.lineWidth : 0;
                            _ctx.beginPath();
                            _ctx.rect(posX, analyzerBottom + offset, width, -barHeight - offset);
                            strokeIf(isOutline);
                            _ctx.fill();
                        }
                    }
                }
                // Draw peak
                const peakValue = bar.peak[channel], peakAlpha = bar.alpha[channel];
                if (peakValue > 0 && peakAlpha > 0 && showPeaks && !showPeakLine && !isLumi && posX >= initialX && posX < finalX) {
                    // set opacity for peak
                    if (_fadePeaks) _ctx.globalAlpha = peakAlpha;
                    else if (isOutline && _lineWidth > 0) _ctx.globalAlpha = 1;
                    else if (isAlpha) _ctx.globalAlpha = peakValue;
                    // select the peak color for 'bar-level' colorMode or 'trueLeds'
                    if (_colorMode == COLOR_BAR_LEVEL || isTrueLeds) setBarColor(peakValue);
                    // render peak according to current mode / effect
                    if (isLeds) {
                        const ledPeak = ledPosY(peakValue);
                        if (ledPeak >= ledSpaceV) _ctx.fillRect(posX, analyzerBottom - ledPeak, width, ledHeight);
                    } else if (!_radial) _ctx.fillRect(posX, analyzerBottom - peakValue * maxBarHeight, width, 2);
                    else if (_mode != MODE_GRAPH) {
                        const y = peakValue * maxBarHeight;
                        radialPoly(posX, y, width, !this._radialInvert || isDualVertical || y + innerRadius >= 2 ? -2 : 2);
                    }
                }
            } // for ( let barIndex = 0; barIndex < nBars; barIndex++ )
            // if not using the canvas, move earlier to the next channel
            if (!useCanvas) continue;
            // restore global alpha
            _ctx.globalAlpha = 1;
            // Fill/stroke drawing path for graph mode
            if (_mode == MODE_GRAPH) {
                setBarColor(); // select channel gradient
                if (_radial && !isDualHorizontal) {
                    if (_mirror) {
                        let p;
                        while(p = points.pop())_ctx.lineTo(...radialXY(...p, -1));
                    }
                    _ctx.closePath();
                }
                if (_lineWidth > 0) _ctx.stroke();
                if (fillAlpha > 0) {
                    if (_radial) {
                        // exclude the center circle from the fill area
                        const start = isDualHorizontal ? getAngle(analyzerWidth >> 1) : 0, end = isDualHorizontal ? getAngle(analyzerWidth) : TAU;
                        _ctx.moveTo(...radialXY(isDualHorizontal ? analyzerWidth >> 1 : 0, 0));
                        _ctx.arc(centerX, centerY, innerRadius, start, end, isDualHorizontal ? !invertedChannel : true);
                    } else {
                        // close the fill area
                        _ctx.lineTo(finalX, analyzerBottom);
                        _ctx.lineTo(initialX, analyzerBottom);
                    }
                    _ctx.globalAlpha = fillAlpha;
                    _ctx.fill();
                    _ctx.globalAlpha = 1;
                }
                // draw peak line (and standard peaks on radial)
                if (showPeakLine || _radial && showPeaks) {
                    points = []; // for mirror line on radial
                    _ctx.beginPath();
                    _bars.forEach((b, i)=>{
                        let x = b.posX, h = b.peak[channel], m = i ? 'lineTo' : 'moveTo';
                        if (_radial && x < 0) {
                            const nextBar = _bars[i + 1];
                            h = findY(x, h, nextBar.posX, nextBar.peak[channel], 0);
                            x = 0;
                        }
                        h *= maxBarHeight;
                        if (showPeakLine) {
                            _ctx[m](..._radial ? radialXY(x, h) : [
                                x,
                                analyzerBottom - h
                            ]);
                            if (_radial && _mirror && !isDualHorizontal) points.push([
                                x,
                                h
                            ]);
                        } else if (h > 0) radialPoly(x, h, 1, -2); // standard peaks (also does mirror)
                    });
                    if (showPeakLine) {
                        let p;
                        while(p = points.pop())_ctx.lineTo(...radialXY(...p, -1)); // mirror line points
                        _ctx.lineWidth = 1;
                        _ctx.stroke(); // stroke peak line
                    }
                }
            }
            _ctx.restore(); // restore clip region
            if (isDualHorizontal && !_radial) _ctx.setTransform(1, 0, 0, 1, 0, 0);
            // create Reflex effect - for dual-combined and dual-horizontal do it only once, after channel 1
            if (!isDualHorizontal && !isDualCombined || channel) doReflex(channel);
        } // for ( let channel = 0; channel < nChannels; channel++ ) {
        updateEnergy(currentEnergy / (nBars << nChannels - 1));
        if (useCanvas) {
            // Mirror effect
            if (_mirror && !_radial && !isDualHorizontal) {
                _ctx.setTransform(-1, 0, 0, 1, canvas.width - initialX, 0);
                _ctx.drawImage(canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height);
                _ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            // restore solid lines
            _ctx.setLineDash([]);
            // draw frequency scale (X-axis)
            drawScaleX();
        }
        // display current frame rate
        if (this.showFPS) {
            const size = canvasX.height;
            _ctx.font = `bold ${size}px ${FONT_FAMILY}`;
            _ctx.fillStyle = FPS_COLOR;
            _ctx.textAlign = 'right';
            _ctx.fillText(Math.round(_fps), canvas.width - size, size * 2);
        }
        // call callback function, if defined
        if (this.onCanvasDraw) {
            _ctx.save();
            _ctx.fillStyle = _ctx.strokeStyle = _canvasGradients[0];
            this.onCanvasDraw(this, {
                timestamp,
                canvasGradients: _canvasGradients
            });
            _ctx.restore();
        }
    }
    /**
	 * Return scaled frequency according to the selected scale
	 */ _freqScaling(freq) {
        switch(this._frequencyScale){
            case SCALE_LOG:
                return Math.log2(freq);
            case SCALE_BARK:
                return 26.81 * freq / (1960 + freq) - .53;
            case SCALE_MEL:
                return Math.log2(1 + freq / 700);
            case SCALE_LINEAR:
                return freq;
        }
    }
    /**
	 * Return the FFT data bin (array index) which represents a given frequency
	 */ _freqToBin(freq, method = 'round') {
        const max = this._analyzer[0].frequencyBinCount - 1, bin = Math[method](freq * this.fftSize / this.audioCtx.sampleRate);
        return bin < max ? bin : max;
    }
    /**
	 * Generate currently selected gradient
	 */ _makeGrad() {
        if (!this._ready) return;
        const { canvas, _ctx, _radial, _reflexRatio } = this, { analyzerWidth, centerX, centerY, initialX, innerRadius, outerRadius } = this._aux, { isLumi } = this._flg, isDualVertical = this._chLayout == CHANNEL_VERTICAL, analyzerRatio = 1 - _reflexRatio, gradientHeight = isLumi ? canvas.height : canvas.height * (1 - _reflexRatio * !isDualVertical) | 0;
        // for vertical stereo we keep the full canvas height and handle the reflex areas while generating the color stops
        for (const channel of [
            0,
            1
        ]){
            const currGradient = this._gradients[this._selectedGrads[channel]], colorStops = currGradient.colorStops, isHorizontal = currGradient.dir == 'h';
            let grad;
            if (_radial) grad = _ctx.createRadialGradient(centerX, centerY, outerRadius, centerX, centerY, innerRadius - (outerRadius - innerRadius) * isDualVertical);
            else grad = _ctx.createLinearGradient(...isHorizontal ? [
                initialX,
                0,
                initialX + analyzerWidth,
                0
            ] : [
                0,
                0,
                0,
                gradientHeight
            ]);
            if (colorStops) {
                const dual = isDualVertical && !this._splitGradient && (!isHorizontal || _radial);
                for(let channelArea = 0; channelArea < 1 + dual; channelArea++){
                    const maxIndex = colorStops.length - 1;
                    colorStops.forEach((colorStop, index)=>{
                        let offset = colorStop.pos;
                        // in dual mode (not split), use half the original offset for each channel
                        if (dual) offset /= 2;
                        // constrain the offset within the useful analyzer areas (avoid reflex areas)
                        if (isDualVertical && !isLumi && !_radial && !isHorizontal) {
                            offset *= analyzerRatio;
                            // skip the first reflex area in split mode
                            if (!dual && offset > .5 * analyzerRatio) offset += .5 * _reflexRatio;
                        }
                        // only for dual-vertical non-split gradient (creates full gradient on both halves of the canvas)
                        if (channelArea == 1) {
                            // add colors in reverse order if radial or lumi are active
                            if (_radial || isLumi) {
                                const revIndex = maxIndex - index;
                                colorStop = colorStops[revIndex];
                                offset = 1 - colorStop.pos / 2;
                            } else {
                                // if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel
                                if (index == 0 && offset > 0) grad.addColorStop(.5, colorStop.color);
                                // bump the offset to the second half of the gradient
                                offset += .5;
                            }
                        }
                        // add gradient color stop
                        grad.addColorStop(offset, colorStop.color);
                        // create additional color stop at the end of first channel to prevent bleeding
                        if (isDualVertical && index == maxIndex && offset < .5) grad.addColorStop(.5, colorStop.color);
                    });
                } // for ( let channelArea = 0; channelArea < 1 + dual; channelArea++ )
            }
            this._canvasGradients[channel] = grad;
        } // for ( const channel of [0,1] )
    }
    /**
	 * Normalize a dB value in the [0;1] range
	 */ _normalizedB(value) {
        const isLinear = this._linearAmplitude, boost = isLinear ? 1 / this._linearBoost : 1, clamp = (val, min, max)=>val <= min ? min : val >= max ? max : val, dBToLinear = (val)=>10 ** (val / 20);
        let maxValue = this.maxDecibels, minValue = this.minDecibels;
        if (isLinear) {
            maxValue = dBToLinear(maxValue);
            minValue = dBToLinear(minValue);
            value = dBToLinear(value) ** boost;
        }
        return clamp((value - minValue) / (maxValue - minValue) ** boost, 0, 1);
    }
    /**
	 * Internal function to change canvas dimensions on demand
	 */ _setCanvas(reason) {
        if (!this._ready) return;
        const { canvas, _ctx } = this, canvasX = this._scaleX.canvas, pixelRatio = window.devicePixelRatio / (this._loRes + 1);
        let screenWidth = window.screen.width * pixelRatio, screenHeight = window.screen.height * pixelRatio;
        // Fix for iOS Safari - swap width and height when in landscape
        if (Math.abs(window.orientation) == 90 && screenWidth < screenHeight) [screenWidth, screenHeight] = [
            screenHeight,
            screenWidth
        ];
        const isFullscreen = this.isFullscreen, isCanvasFs = isFullscreen && this._fsEl == canvas, newWidth = isCanvasFs ? screenWidth : (this._width || this._container.clientWidth || this._defaultWidth) * pixelRatio | 0, newHeight = isCanvasFs ? screenHeight : (this._height || this._container.clientHeight || this._defaultHeight) * pixelRatio | 0;
        // set/update object properties
        this._pixelRatio = pixelRatio;
        this._fsWidth = screenWidth;
        this._fsHeight = screenHeight;
        // if this is not the constructor call and canvas dimensions haven't changed, quit
        if (reason != REASON_CREATE && canvas.width == newWidth && canvas.height == newHeight) return;
        // apply new dimensions
        canvas.width = newWidth;
        canvas.height = newHeight;
        // if not in overlay mode, paint the canvas black
        if (!this.overlay) {
            _ctx.fillStyle = '#000';
            _ctx.fillRect(0, 0, newWidth, newHeight);
        }
        // set lineJoin property for area fill mode (this is reset whenever the canvas size changes)
        _ctx.lineJoin = 'bevel';
        // update dimensions of the scale canvas
        canvasX.width = newWidth;
        canvasX.height = Math.max(20 * pixelRatio, Math.min(newWidth, newHeight) / 32 | 0);
        // calculate bar positions and led options
        this._calcBars();
        // (re)generate gradient
        this._makeGrad();
        // detect fullscreen changes (for Safari)
        if (this._fsStatus !== undefined && this._fsStatus !== isFullscreen) reason = REASON_FSCHANGE;
        this._fsStatus = isFullscreen;
        // call the callback function, if defined
        if (this.onCanvasResize) this.onCanvasResize(reason, this);
    }
    /**
	 * Select a gradient for one or both channels
	 *
	 * @param {string} name gradient name
	 * @param [{number}] desired channel (0 or 1) - if empty or invalid, sets both channels
	 */ _setGradient(name, channel) {
        if (!this._gradients.hasOwnProperty(name)) throw new AudioMotionError(ERR_UNKNOWN_GRADIENT, name);
        if (![
            0,
            1
        ].includes(channel)) {
            this._selectedGrads[1] = name;
            channel = 0;
        }
        this._selectedGrads[channel] = name;
        this._makeGrad();
    }
    /**
	 * Set object properties
	 */ _setProps(options, useDefaults) {
        // callback functions properties
        const callbacks = [
            'onCanvasDraw',
            'onCanvasResize'
        ];
        // properties not in the defaults (`stereo` is deprecated)
        const extraProps = [
            'gradientLeft',
            'gradientRight',
            'stereo'
        ];
        // build an array of valid properties; `start` is not an actual property and is handled after setting everything else
        const validProps = Object.keys(DEFAULT_SETTINGS).filter((e)=>e != 'start').concat(callbacks, extraProps);
        if (useDefaults || options === undefined) options = {
            ...DEFAULT_SETTINGS,
            ...options
        }; // merge options with defaults
        for (const prop of Object.keys(options)){
            if (callbacks.includes(prop) && typeof options[prop] !== 'function') this[prop] = undefined;
            else if (validProps.includes(prop)) this[prop] = options[prop];
        }
        // deprecated - move this to the constructor in the next major release (`start` should be constructor-specific)
        if (options.start !== undefined) this.toggleAnalyzer(options.start);
    }
}
;
const __TURBOPACK__default__export__ = AudioMotionAnalyzer;
}}),

};

//# sourceMappingURL=node_modules_d419d0._.js.map